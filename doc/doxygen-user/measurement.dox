/** @page measurement Application measurement

If an application was instrumented with @scorep, you will get an executable, which 
you can execute like the uninstrumented application. After the application run, you
will find a measurement directory in your current working directory, which contains
all recorded data. The measurement directory has the format 
<tt>scorep-YYYYMMDD_XXXX_XXXX</tt>, where <tt>YYYYMMDD</tt> encodes the date followed
by a series of random numbers.

In general, you can record a profile and/or a event trace. Whether a profile and/or a
trace is recorded, is specified by the environment variables 
<tt>SCOREP_ENABLE_PROFILING</tt> and <tt>SCOREP_ENABLE_TRACING</tt>. If the value of this
variables is not set, zero or <tt>false</tt>, profiling/tracing is disabled. 
Otherwise @scorep will record a profile and/or trace.

You may start with a profiling run, because of its lower space requirements. According
to profiling results, you may configure the trace buffer limits, filtering or selective 
tracing for recording traces.



@section profiling Profiling
@seclabel{profiling}

Score-P implements a call-tree based profiling system. Every node in the call tree 
represent a recorded region. The edges of the tree represent the caller-callee 
relationship: The children of a node are those regions, that are entered/exited within 
a region. The path from the root to an arbitrary node, represents a call-path. Thus, 
every node in the tree identifies also the call-path from the root to itself. 

Together with a node, the statistics for the call-path are stored. 
By default, the runtime and the number of visits are recorded. Additionally, hardware
counters can be configured and are stored for every call-path. User defined metrics
are only stored in those nodes, where the metric was triggered.

For enabling profiling, set the environment variable <tt>SCOREP_ENABLE_PROFILING</tt>
to 1 or <tt>true</tt>. After the execution of your application you will then find
a <tt>profile.cubex</tt> file in your measurement directory, which you can display
with the @cube4 with <tt>cube-qt profile.cubex</tt>. The name of the profile can be
changed through the environment variable <tt>SCOREP_PROFILING_BASE_NAME</tt>. The
extension <tt>.cubex</tt> will we appended to the base name you specify in
<tt>SCOREP_PROFILING_BASE_NAME</tt>. 

If you want to record the profile in TAU snapshot format instead of the @cube4 format,
set <tt>SCOREP_PROFILING_FORMAT=TAU_SNAPSHOT</tt>. Vice versa, you might set 
<tt>SCOREP_PROFILING_FORMAT=CUBE4</tt> to get a @cube4 profile.

@scorep records a call tree profile. The maximum call-path depth that is recorded 
is limited to 30, by default. This avoids
extremely large profiles for recursive calls. However, this limit can be changed with
the environment variable <tt>SCOREP_PROFILING_MAX_CALLPATH_DEPTH</tt>. 


@subsection parameter_profiling Parameter-based profiling

Parameter-based profiling allows to separate the recoded statistics for a region, 
depending on the values of one or multiple parameters. In the resulting call-tree,
each occurred parameter-value will create a sub-node of the region. Every parameter has
a parameter name. Thus, if multiple parameters are used, they can be distinguished and 
split the call-tree in the order of the parameter events. In the final call-tree it
looks like every parameter-name/parameter-value pair is a separate region.

Currently, the only source parameter events is @secref{parameter_instrumentation}.


@subsection phase_profiling Phase profiling

Phase-profiling allows, to group the execution of the application into logical phases.
Score-P records a separate call-tree for every phase in the application. A phase starts
when a region of type <tt>SCOREP_USER_REGION_TYPE_PHASE</tt> 
(see @secref{manual_instrumentation}) is entered. If the region is exited, the phase
is left. If two phases are nested, then the outer phase is left, when the inner phase is
entered. If the inner phase is exited, the outer phase is re-entered.

If the phase consists of multiple partitions, and thus can not be enclosed by a single
code region, all code-regions that form the phase must have the same region handle.
The possibility to define global region handles in C/C++ might be useful for the 
definition of phases that are have multiple partitions  
(see @secref{manual_instrumentation}). 


@section filtering Filtering
@seclabel{filtering}

When automatic compiler instrumentation or automated source code instrumentation 
PDT has been used to instrument user-level source-program routines, there
are cases where measurement and associated analysis are degraded,
e.g., by small, frequently-executed and/or generally uninteresting
functions, methods and subroutines.

A measurement filtering capability is therefore supported for compiler instrumented
regions, regions instrumented with @scorep user API and regions from 
@secref{pomp_instrumentation}. Because @secref{tau_instrumentation} inserts,
@scorep user API instrumentation, those regions can be filtered, too.
Regions can be filtered based on their region name (e.g., their function name)
or based on the source file, in which they are defined. 

A file containing the filter definition can be specified via the environment
variable <tt>SCOREP_FILTERING_FILE</tt>. If no filter definition file is specified,
all instrumented regions are recorded. For filtered regions, the enter/exit events
are nor recorded in trace and profile.

The filter definition file can contain two blocks:
<ul>
  <li> One block defines filter rules for filtering regions based on the source files
       they are defined in.
  </li>
  <li> One filter block defined rules for region names.
  </li>
</ul>

When the filter rules are applied, the source file name filter is evaluated first. If
a region is filtered because it appears in a filtered source file, it can not be included
by the function name filter. If a region was defined in a not-filtered source file,
the region name filter is evaluated. This means, events for a region are not recorded
it it is filtered by the source file filter or the region name filter. Events for
a region are recorded if the region is neither filtered by the source file filter nor
by the region name filter. If one of the both filter blocks is not specified, it is 
equivalent to an empty filter block.

Beside the two filter blocks, you may use comments in the filter definition file. 
Comments start with the character '#' and everything behind this character is ignored.
You may use comments also inside the filter blocks. If a region name or source file
name contains '#', you must escape it with a backslash.

@subsection source_filtering Source file name filter block
@seclabel{source_filtering}

The filter block for the source file names, must be enclosed by 
<tt>SCOREP_FILE_NAMES_BEGIN</tt> and <tt>SCOREP_FILE_NAMES_END</tt>. In between you
can specify an arbitrary number of include and exclude rules, that are evaluated in
sequential order. At the beginning all source files are included. Source files that 
are excluded after all rules are evaluated, are filtered.

An exclude rule starts with the keyword <tt>EXCLUDE</tt> followed by
one or multiple whitespace separated expression which is matched against the 
source file names. Respectively, include rules start with <tt>INCLUDE</tt>
followed by one or multiple whitespace separated expressions. An example source
file filter block could look like this:
@code
SCOREP_FILE_NAMES_BEGIN # This is a comment
  EXCLUDE */filtering/filter*
  INCLUDE filter_test.c
SCOREP_FILE_NAMES_END
@endcode

@note The keywords (e.g., <tt>SCOREP_FILE_NAMES_BEGIN</tt>, 
<tt>SCOREP_FILE_NAMES_END</tt>,<tt>EXCLUDE</tt>, and <tt>INCLUDE</tt> are 
case-sensitive.

For evaluating the expressions the fnmatch() function is used with no flags set 
(see http://pubs.opengroup.org/onlinepubs/009695399/functions/fnmatch.html for a 
detailed definition of fnmatch()). The most widely used expressions are exact
matches, where you specify the exact name as expression, or '*' and '?' wild-cards
with a bash-like semantic. 

If the expression contains at least one slash, @scorep will match the 
expression against the full path of the source file. If the expression contains no 
slashes, @scorep will strip the path from the source file name before matching it 
with the expression. E.g., assume the following files exist:
@code
/foobar/file1
/bar/file1
/foo/bar/file1
@endcode
<ul>
  <li> The expression <tt>file1</tt> would match all three files, because the path is 
       stripped before comparison.</li>
  <li> The expression <tt>/bar/file1</tt> matches only <tt>/bar/file1</tt>. </li>
  <li> <tt>*bar/file1</tt> matches all three files. </li>
</ul>

@note If the source code file name has a relative path, it is not possible to 
      reconstruct the absolute path of the source file at runtime. If the expression
      describes a relative path, the absolute path is not reconstructed, too.
      Thus, the relative path may not be matched with the absolute path, even if they do
      in reality. This missing matches can be avoided by using a '*'-wildcard prefix.


@subsection region_filtering Region name filter block
@seclabel{region_filtering}

The filter block for the region names, must be enclosed by 
<tt>SCOREP_REGION_NAMES_BEGIN</tt> and <tt>SCOREP_REGION_NAMES_END</tt>. In between you
can specify an arbitrary number of include and exclude rules, that are evaluated in
sequential order. At the beginning all regions are included. Regions that 
are excluded after all rules are evaluated, are filtered. 

@note Regions that are defined in source files that are filtered, are excluded
      due to the source file filter. They can not be included anymore by an
      include rule in the region filter block.

An exclude rule starts with the keyword <tt>EXCLUDE</tt> followed by
one or multiple whitespace separated expression which is matched against the 
region names. Respectively, include rules start with <tt>INCLUDE</tt>
followed by one or multiple whitespace separated expressions. An example region
filter block could look like this:
@code
SCOREP_REGION_NAMES_BEGIN
  EXCLUDE *
  INCLUDE filter_not2 filtered2
          filter_not1
          main
SCOREP_REGION_NAMES_END
@endcode

@note The keywords (e.g., <tt>SCOREP_REGION_NAMES_BEGIN</tt>, 
<tt>SCOREP_REGION_NAMES_END</tt>,<tt>EXCLUDE</tt>, and <tt>INCLUDE</tt> are 
case-sensitive.

For evaluating the expressions the fnmatch() function is used with no flags set 
(see http://pubs.opengroup.org/onlinepubs/009695399/functions/fnmatch.html for a 
detailed definition of fnmatch()). The most widely used expressions are exact
matches, where you specify the exact name as expression, or <tt>*</tt> and <tt>?</tt> 
wild-cards with a bash-like semantic. 

Some instrumentation methods provide only mangled function names for Fortran
subroutines and functions, where the name is made all upper/lower case or decorated
with underscores. To keep a filter definition portable, we provide the <tt>FORTRAN</tt>
keyword, which must be specified between the <tt>INCLUDE</tt> or <tt>EXCLUDE</tt>
and the expression. It will cause @scorep to consider the effects of mangling when
evaluating the expression. A Fortran rule would look like this:
@code
  EXCLUDE FORTRAN MyFortranSub
@endcode

@section selective_tracing Selective tracing
@seclabel{selective_tracing}

@scorep experiments record by default all events during the whole execution run.
If tracing is enabled of the event data are collected in buffers on each process 
that must be adequately sized to store events from the entire execution.

Instrumented routines which are executed frequently, while only performing a
small amount of work each time they are called, have an undesirable impact on
measurement. The measurement overhead for such routines is large in 
comparison to the execution time of the uninstrumented routine, resulting in
measurement dilation. Recording these events requires significant space and
analysis takes longer with relatively little improvement in quality.
Filtering can be employed during measurement (described in @secref{filtering}) to
ignore events from compiler-instrumented routines or user-instrumented routines.

Another possibility is not to record the whole application run. In many cases, 
only parts of the application are of interest for analysis (e.g. a frequently
performed calculation) while other parts are of less interest (e.g., initialization
and finalization) for performance analysis. Or the calculation itself shows 
iterative behavior, where recording of one iteration would be sufficient for
analysis. Restricting recording to one or multiple time intervals during 
measurement would reduce the required space and overhead. This approach is called 
selective tracing.

@scorep provides two possibilities for selective tracing.
<ul>
  <li> A configuration file can specify traced regions. The entry and exit of those 
       regions define an interval during which events are recored. </li>
  <li> With user instrumentation, the recording can be manually switched on /off.
       (See Section @secref{manual_instrumentation}). 
</ul>

Switching recording on or off, can result in inconsistent traces or profiles, if not
applied with care. Especially, switching recording on/off manually via the SCOREP user
instrumentation macros <tt>SCOREP_USER_RECORDING_ON</tt> and 
<tt>SCOREP_USER_RECORDING_OFF</tt> is not recommended. Inconsistent traces may result in
errors or deadlocks during analysis, or show unusable data. The consistency is endangered
if:
<ul>
  <li> @openmp events are missing in one thread while other threads have them. 
       Furthermore, the @openmp parallel region events are required if any event 
       inside a parallel region is recorded. To prevent inconsistencies from 
       incomplete recording of @openmp events, it is not possible to switch 
       recording on/off from inside a parallel region </li>
  <li> @mpi a communication is only recorded partially, e.g. if a send is missing, but
       the corresponding receive on another process is recorded. To ensure recording
       of complete communication is the responsibility of the user. 
  <li> enter/exit events are not correctly nested. <li>
</ul>

The usage of the @scorep user macros <tt>SCOREP_USER_RECORDING_ON</tt> and 
<tt>SCOREP_USER_RECORDING_OFF</tt> is explained in 
Section @secref{manual_instrumentation}. Thus, this section focuses on first
possibility, where the user specify traced regions via a configuration file.
Currently, selective tracing is restricted to trace recording. In profiling
is enabled, the profile will always summarize the whole execution.

For selective tracing, you can specify one or multiple traced regions. The 
recording is enabled when a traced region is entered. If the region is exited,
recording of events is switched off again. If a traced region is called inside 
another traced region, thus, the recording is already enabled, it will not disable
recording of it exits, but recording will be switched off, if all traced regions are
exited. 

For traced regions only regions from @scorep user instrumentation can be selected.
If regions from other instrumentation methods are specified in the configuration
file for selective tracing, they are ignored.

For a traced region, the recording can be restricted to certain executions of that
region. Therefor, the enters for a traced region are counted, and a particular
execution can be specified by the number of its enter. If a traced region is called
recursively, the recording is only switched off, if the exit is reached, that 
corresponds to the enter that enabled recording.

The configuration file is a simple text file, where every line contains the name of 
exactly one region. Optionally, a 
comma-separated list of execution numbers or intervals of execution numbers can be 
specified. A configuration file could look like follows:
@code
    foo
    bar 23:25, 50, 60:62
    baz 1
@endcode
This configuration file would record all executions of foo, the executions 23, 24, 25,
50, 60, 61, and 62 of bar, and the second (numbering starts with 0) execution of baz 
are recorded.

To apply the selective tracing configuration file to a measurement run of your 
application, set the environment variable <tt>SCOREP_SELECTIVE_CONFIG_FILE</tt>
to the configuration file and run your instrumented application. If 
<tt>SCOREP_SELECTIVE_CONFIG_FILE</tt> is empty, or the given file can not be opened,
the whole application run will be recorded (no selective tracing will apply).
*/
