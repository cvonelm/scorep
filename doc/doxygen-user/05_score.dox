/** @page score Usage of scorep-score
@seclabel{score}

scorep-score is a tool that allows to estimate the size of an OTF2 trace 
from a CUBE4 profile. Furthermore, the effects of 
filters are estimated. The main goal is to define appropriate filters for
a tracing run from a profile.

The general workflow for performance analysis with Score-P is:
<ol>
  <li> Instrument an application (see Section @secref{instrumentation}).</li>
  <li> Perform a measurement run and record a profile (see Section @secref{measurement}). 
       The profile already
       gives an overview what may happen inside the application. </li>
  <li> Use scorep-score to define an appropriate filter for an application
       Otherwise the trace file may become too large. This step is explained
       in this Chapter.</li>
  <li> Perform a measurement run whith tracing enabled and the filter
       applied (see Section @secref{tracing} and Section @secref{filtering}). </li>
  <li> Perform in-depth analysis on the trace data.</li>
</ol>


To invoke @verb{scorep-score} you must provide the filename of a CUBE4 profile as
argument. Thus, the basic command looks like this:

@verbatim
scorep-score profile.cubex
@endverbatim

The output of the command may look like this:

@verbatim
Estimated aggregate size of event trace (total_tbc):       24224 bytes
Estimated requirements for largest trace buffer (max_tbc): 6381 bytes
(hint: When tracing set SCOREP_TOTAL_MEMORY > max_tbc to avoid intermediate flushes
 or reduce requirements using file listing names of USR regions to be filtered.)

flt type         max_tbc         time      % region
     ALL            6381         4.24  100.0 ALL
     OMP            4192         3.39   79.8 OMP
     MPI            1901         0.24    5.6 MPI
     COM             264         0.62   14.6 COM
     USR              24         0.00    0.0 USR
@endverbatim

The first line of the output gives an estimation of the total size of the trace, 
aggragated over all processes. This information is useful for estimating the space
required on disk. In the given example, the estimated total size of the event 
trace is 24224 bytes. 

The second line prints an estimation of the memory space required
by a single process for the trace. The memory space that @scorep reserves on each process
at application start must be large enough to hold the process' trace in memory 
in order to avoid flushes during runtime, because flushes heavily disturb 
measurements. The memory size per process that @scorep reserves is set via the 
environment variable @verb{SCOREP_TOTAL_MEMORY}. In the given example the per 
process memory should be larger than 6381 bytes.

Beginning with the 6th line, @verb{scorep-score} prints a table that show
how the trace memory requirements and the runtime is distributed among certain function 
groups. The column @verb{max_tbc} shows how much trace buffer is needed 
on a single process. The column @verb{time} shows how much execution time was spend 
in regions of that group, and the column @verb{%} shows the fraction of the overall 
runtime that was used by this group.

The following groups exist:
<ul>
 <li> ALL: Includes all functions of the application </li>
 <li> OMP: This group contains all regions that represent an OpenMP construct </li>
 <li> MPI: This group contains all MPI functions </li>
 <li> COM: This group contains all functions, implemented by the user that apprear on 
           a callpath to an MPI function or an OpenMP construct </li>
 <li> USR: This group contains all user functions that do not appear on a callpath to
           an OpenMP coinstruct or MPI function. </li>
</ul>

For a more detailed output, which shows the data for every region, you can use the 
@verb{-r} option. The command could look like this.

@verbatim
scorep-score profile.cubex -r
@endverbatim

This command adds information about the used buffer sizes and execution time of every 
region to the table. The additional lines of the output may look like this:

@verbatim
flt type         max_tbc         time      % region

     COM              24         0.00    0.0 main
     USR              24         0.00    0.0 PrintResults
     COM              24         0.00    0.1 Finish
     MPI              24         0.01    0.4 MPI_Init_thread
     COM              24         0.00    0.0 Init
@endverbatim

The region name is displayed in the column named @verb{region}.
The column @verb{type} shows to which group this region belongs. 
In the example above the function main belongs to group @verb{COM}
required 24 bytes per process and used 0~s execution time. The
regions are sorted by their buffer requirements.

For defining a filter, it is recommended to exclude short frequently called
functions from measurement, because they require a lot of
buffer space (represented by a high value under @verb{max_tbc}) but incur a high
measurement overhead. Furthermore, for communication analysis, functions 
that appear on a callpath to MPI functions and OpenMP constructs (regions
of type @verb{COM}) are usually of more interest than user functions of type @verb{USR}
which do not appear on callpath to communications. MPI functions and OpenMP
constructs can not be filtered. Thus, it is usually a good approach to exclude
regions of type @verb{USR} starting at the top of the list until you reduced the trace
to your needs. Section @secref{filtering} describes the format of a filter 
specification file.

// the -f option

// the -c option

@latexonly
\appendices
\renewcommand\chaptername{Appendix}

@endlatexonly
*/
