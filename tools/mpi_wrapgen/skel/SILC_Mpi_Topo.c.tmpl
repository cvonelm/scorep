#include "SILC_Mpi.h"
#include "SILC_DefinitionLocking.h"
#include "config.h"

/**
 * @file       SILC_Mpi_Topo.c
 * @maintainer Daniel Lorenz <d.lorenz@fz-juelich.de>
 * @status     ALPHA
 * @ingroup    MPI_Wrapper
 *
 * @brief C interface wrappers for topologies
 */

/**
 * @name C wrappers
 * @{
 */

#if HAVE(DECL_PMPI_CART_CREATE)
/** 
 * Measurement wrapper for MPI_Cart_create
 * @note Manually adapted wrapper
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup topo
 * Sequence of events:
 * @li enter region 'MPI_Cart_create'
 * @li define communicator
 * @li define topology
 * @li define coordinates
 * @li exit region 'MPI_Cart_create'
 */
int MPI_Cart_create(MPI_Comm  comm_old,
                    int       ndims,
                    int*      dims,
                    int*      periodv,
                    int       reorder,
                    MPI_Comm* comm_cart)
{
  const int32_t event_gen_active = SILC_MPI_IS_EVENT_GEN_ON_FOR(SILC_MPI_ENABLED_TOPO);
  int32_t       return_val;

  if (event_gen_active)
  {
    SILC_MPI_EVENT_GEN_OFF();
    SILC_EnterRegion(silc_mpi_regid[SILC__MPI_CART_CREATE]);
  }

  return_val = PMPI_Cart_create(comm_old, ndims, dims, periodv, reorder, comm_cart);

  if (*comm_cart != MPI_COMM_NULL)
  {
    SILC_MPICartTopolHandle topid = SILC_INVALID_CART_TOPOLOGY;
    int32_t   cid, my_rank, i;
    int32_t*  coordv;
    uint8_t*  uperiodv;
    uint32_t* udimv;
    uint32_t* ucoordv;

    /* register the new topology communicator */
    silc_mpi_comm_create(*comm_cart);
  
    /* get the internal comminicator id for the communicator of the new topology */
    cid = silc_mpi_comm_id(*comm_cart);

    /* find the rank of the calling process */
    PMPI_Comm_rank(*comm_cart, &my_rank); 
  
    /* assign the cartesian topology dimension parameters */
    udimv   = calloc(ndims, sizeof(uint32_t));
    if (!udimv)
    {
      SILC_ERROR_POSIX();
    }
    
    uperiodv = calloc(ndims, sizeof(uint8_t));
    if (!uperiodv)
    {
      SILC_ERROR_POSIX();
    }

    for (i = 0 ; i < ndims ; i++)
    {
      udimv[i]    =  (uint32_t) dims[i];
      uperiodv[i] =  (uint8_t)  periodv[i];
    }
          
    /* create the cartesian topology definition record */
    SILC_LockMPICartesianTopologyDefinition();
    topid = SILC_DefineMPICartesianTopology("", cid, ndims, udimv, uperiodv);
    SILC_UnlockMPICartesianTopologyDefinition();

     /* allocate space for coordv and ucoordv */
    coordv = calloc(ndims, sizeof(int));
    if (!coordv)
    {
      SILC_ERROR_POSIX();
    }

    ucoordv = calloc(ndims, sizeof(uint32_t));
    if (!ucoordv)
    {
      SILC_ERROR_POSIX();
    }
                          
    /* get the coordinates of the calling process in coordv */
    PMPI_Cart_coords(*comm_cart, my_rank, ndims, coordv);

    /* assign the coordinates */
    for ( i = 0 ; i < ndims ; i++ )
    {
      ucoordv[i] = (uint32_t) coordv[i];
    }
  
    /* create the coordinates definition record */
    SILC_LockMPICartesianCoordsDefinition();
    SILC_DefineMPICartesianCoords(topid, ndims, ucoordv);               
    SILC_UnlockMPICartesianCoordsDefinition();

    free(udimv);
    free(uperiodv);
    free(ucoordv);
  }

  if (event_gen_active)
  {
    SILC_ExitRegion(silc_mpi_regid[SILC__MPI_CART_CREATE]);
    SILC_MPI_EVENT_GEN_ON();
  }

  return return_val;
}
#endif

#pragma wrapgen single MPI_Cart_sub skel/SILC_Mpi_CommMgnt.w
#pragma wrapgen single MPI_Graph_create skel/SILC_Mpi_CommMgnt.w

#pragma wrapgen multiple restrict(gtopo+!ncreate+!nsub) skel/SILC_Mpi_Std.w
#pragma wrapgen single MPI_Dims_create skel/SILC_Mpi_Std.w

/**
 * @}
 */
