/****************************************************************************
**  SCALASCA    http://www.scalasca.org/                                   **
**  KOJAK       http://www.fz-juelich.de/jsc/kojak/                        **
*****************************************************************************
**  Copyright (c) 1998-2009                                                **
**  Forschungszentrum Juelich, Juelich Supercomputing Centre               **
**                                                                         **
**  Copyright (c) 2003-2008                                                **
**  University of Tennessee, Innovative Computing Laboratory               **
**                                                                         **
**  See the file COPYRIGHT in the package base directory for details       **
****************************************************************************/

#include "SILC_Mpi.h"
#include "config.h"

/**
 * @file  SILC_Mpi_Topo.c
 *
 * @brief C interface wrappers for topologies
 */

/**
 * @name C wrappers
 * @{
 */

#if defined(HAVE_DECL_MPI_CART_CREATE)
/** 
 * Measurement wrapper for MPI_Cart_create
 * @note Manually adapted wrapper
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup topo
 */
int MPI_Cart_create(MPI_Comm  comm_old,
                    int       ndims,
                    int*      dims,
                    int*      periodv,
                    int       reorder,
                    MPI_Comm* comm_cart)
{
  const int32_t event_gen_active = SILC_MPI_IS_EVENT_GEN_ON_FOR(SILC_MPI_ENABLED_TOPO);
  int32_t       return_val;

  if (event_gen_active)
  {
    SILC_MPI_EVENT_GEN_OFF();
    SILC_EnterRegion(silc_mpi_regid[SILC__MPI_CART_CREATE]);
  }

  return_val = PMPI_Cart_create(comm_old, ndims, dims, periodv, reorder, comm_cart);

  if (*comm_cart != MPI_COMM_NULL)
  {
    SILC_MPICartTopolHandle topid = SILC_INVALID_CART_TOPOLOGY;
    int32_t   cid, my_rank, i;
    int32_t*  coordv;
    uint8_t*  uperiodv;
    uint32_t* udimv;
    uint32_t* ucoordv;

    /* register the new topology communicator */
    silc_mpi_comm_create(*comm_cart);
  
    /* get the internal comminicator id for the communicator of the new topology */
    cid = silc_mpi_comm_id(*comm_cart);

    /* find the rank of the calling process */
    PMPI_Comm_rank(*comm_cart, &my_rank); 
  
    /* assign the cartesian topology dimension parameters */
    udimv   = calloc(ndims, sizeof(uint32_t));
    if (!udimv)
    {
      SILC_ERROR_POSIX();
    }
    
    uperiodv = calloc(ndims, sizeof(uint8_t));
    if (!uperiodv)
    {
      SILC_ERROR_POSIX();
    }

    for (i = 0 ; i < ndims ; i++)
    {
      udimv[i]    =  (uint32_t) dims[i];
      uperiodv[i] =  (uint8_t)  periodv[i];
    }
          
    /* create the cartesian topology definition record */
    topid = SILC_DefineMPICartesianTopology("", cid, ndims, udimv, uperiodv);

     /* allocate space for coordv and ucoordv */
    coordv = calloc(ndims, sizeof(int));
    if (!coordv)
    {
      SILC_ERROR_POSIX();
    }

    ucoordv = calloc(ndims, sizeof(uint32_t));
    if (!ucoordv)
    {
      SILC_ERROR_POSIX();
    }
                          
    /* get the coordinates of the calling process in coordv */
    PMPI_Cart_coords(*comm_cart, my_rank, ndims, coordv);

    /* assign the coordinates */
    for ( i = 0 ; i < ndims ; i++ )
    {
      ucoordv[i] = (uint32_t) coordv[i];
    }
  
    /* create the coordinates definition record */
    SILC_DefineMPICartesianCoords(topid, ndims, ucoordv);               

    free(udimv);
    free(uperiodv);
    free(ucoordv);
  }

  if (event_gen_active)
  {
    SILC_ExitRegion(silc_mpi_regid[SILC__MPI_CART_CREATE]);
    SILC_MPI_EVENT_GEN_ON();
  }

  return return_val;
}
#endif

#pragma wrapgen single MPI_Cart_sub skel/SILC_Mpi_CommMgnt.w
#pragma wrapgen single MPI_Graph_create skel/SILC_Mpi_CommMgnt.w

#pragma wrapgen multiple restrict(gtopo+!ncreate+!nsub) skel/SILC_Mpi_Std.w
#pragma wrapgen single MPI_Dims_create skel/SILC_Mpi_Std.w

/**
 * @}
 */
