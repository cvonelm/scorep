${guard:start}
/**
 * Measurement wrapper for ${name}
 * @note Auto-generated by wrapgen from template: coll.w
 * @note C interface
 * @note Introduced with MPI-${mpi:version}
 * @ingroup ${group|lowercase}
 * It wraps the mpi call with an enter and exit event. Additionally, a collective
 * event is generated in between the enter and exit event after the PMPI call.
 */
${proto:c}
{
  SCOREP_IN_MEASUREMENT_INCREMENT();
  ${rtype} return_val;

  if (SCOREP_MPI_IS_EVENT_GEN_ON_FOR(SCOREP_MPI_ENABLED_${group|uppercase}))
    {
      ${decl}
      SCOREP_MPI_EVENT_GEN_OFF();
      ${xblock}

      SCOREP_EnterWrappedRegion(scorep_mpi_regid[SCOREP__${name|uppercase}], ( intptr_t )P${name});
      SCOREP_MpiCollectiveBegin();
      uint64_t start_time_stamp =
        SCOREP_Location_GetLastTimestamp( SCOREP_Location_GetCurrentCPULocation() );

      SCOREP_ENTER_WRAPPED_REGION();
      return_val = ${call:pmpi};
      SCOREP_EXIT_WRAPPED_REGION();

      ${guard:hooks}
        ${check:hooks}
          ${call:posthook};
      ${guard:end}

      SCOREP_MpiCollectiveEnd(SCOREP_MPI_COMM_HANDLE(comm),
                              root_loc,
                              SCOREP_MPI_COLLECTIVE__${name|uppercase},
                              ${mpi:sendcount},
                              ${mpi:recvcount});
      SCOREP_ExitRegion(scorep_mpi_regid[SCOREP__${name|uppercase}]);

      SCOREP_MPI_EVENT_GEN_ON();
    }
  else
    {
      return_val = ${call:pmpi};
    }
  SCOREP_IN_MEASUREMENT_DECREMENT();

  return return_val;
}
${guard:end}
