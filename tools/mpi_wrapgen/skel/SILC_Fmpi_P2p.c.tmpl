
/**
 * @file  SILC_Fmpi_P2p.c
 * @maintainer Daniel Lorenz <d.lorenz@fz-juelich.de>
 * @status     ALPHA
 * @ingroup    MPI_Wrapper
 *
 * @brief Fortran interface wrappers for point-to-point communication
 */

#include "SILC_Fmpi.h"
#include "config.h"

/* uppercase defines */
#pragma wrapgen multiple restrict(gp2p) skel/SILC_Fmpi_DefineU.w

/* lowercase defines */
#pragma wrapgen multiple restrict(gp2p) skel/SILC_Fmpi_DefineL.w

#ifndef NEED_F2C_CONV

/* If MPI_Comm_f2c is HAVE as a simple macro (which typically does nothing)
 * as it would require a "real" function if it is really needed
 * => we can save the f2c and c2s conversions */

#if HAVE(DECL_PMPI_WAITANY) && !defined(SILC_MPI_NO_P2P)
/**
 * Manual measurement wrapper for the Fortran interface of MPI_Waitany
 * @note C indices have to be converted to Fortran indices, when the
 *       effective index is not MPI_UNDEFINED
 * @ingroup manual_fortran_mpi_1_p2p
 */
void FSUB(MPI_Waitany)(int*         count,
                       MPI_Request* array,
                       int*         index,
                       MPI_Status*  status,
                       int*         ierr)
{
  *ierr = MPI_Waitany(*count, array, index, status);
  
  if ((*index != MPI_UNDEFINED) && (*index >= 0))
  {
    (*index)++;
  }
}
#endif

#if HAVE(DECL_PMPI_WAITSOME) && !defined(SILC_MPI_NO_P2P)
/**
 * Manual measurement wrapper for the Fortran interface of MPI_Waitsome
 * @note C indices have to be converted to Fortran indices, when the
 *       effective index is not MPI_UNDEFINED
 * @ingroup manual_fortran_mpi_1_p2p
 */
void FSUB(MPI_Waitsome)(int*         incount,
                        MPI_Request* array_of_requests,
                        int*         outcount,
                        int*         array_of_indices,
                        MPI_Status*  array_of_statuses,
                        int*         ierr)
{
  int i;

  *ierr = MPI_Waitsome(*incount, array_of_requests, outcount,
                array_of_indices, array_of_statuses); 
  if (*outcount != MPI_UNDEFINED)
  {
    for (i=0; i < *outcount; i++)
    {
      if (array_of_indices[i] >= 0)
      {
        array_of_indices[i]++;
      }
    }
  }
}
#endif

#if HAVE(DECL_PMPI_TESTANY) && !defined(SILC_MPI_NO_P2P)
/**
 * Manual measurement wrapper for the Fortran interface of MPI_Testany
 * @note C indices have to be converted to Fortran indices, when the
 *       effective index is not MPI_UNDEFINED
 * @ingroup manual_fortran_mpi_1_p2p
 */
void FSUB(MPI_Testany)(int*         count,
                       MPI_Request* array_of_requests,
                       int*         index,
                       int*         flag,
                       MPI_Status*  status,
                       int*         ierr)
{
  *ierr  = MPI_Testany(*count, array_of_requests, index, flag, status);
  
  /* convert index to Fortran */
  if ((*ierr == MPI_SUCCESS) 
      && *flag 
      && (*index != MPI_UNDEFINED) 
      && (*index >= 0)) 
  {
    (*index)++;
  }
}
#endif

#if HAVE(DECL_PMPI_TESTSOME) && !defined(SILC_MPI_NO_P2P)
/**
 * Manual measurement wrapper for the Fortran interface of MPI_Testsome
 * @note C indices have to be converted to Fortran indices, when the
 *       effective index is not MPI_UNDEFINED
 * @ingroup manual_fortran_mpi_1_p2p
 */
void FSUB(MPI_Testsome)(int*         incount,
                        MPI_Request* array_of_requests,
                        int*         outcount,
                        int*         array_of_indices,
                        MPI_Status*  array_of_statuses,
                        int*         ierr)
{
  int i;

  *ierr = MPI_Testsome(*incount, array_of_requests, outcount, array_of_indices,
                array_of_statuses);

  /* convert indices to Fortran */
  if ((*ierr == MPI_SUCCESS) && (*outcount != MPI_UNDEFINED))
  {
    for (i=0; i<*outcount; i++)
    {
      if (array_of_indices[i] >= 0)
      {
        array_of_indices[i]++;
      }
    }
  }
}
#endif

#pragma wrapgen multiple restrict(gp2p+!nsome+!nany) skel/SILC_Fmpi_Std.w

#else /* !NEED_F2C_CONV */

/**
 * Wrapper for a statically allocated request array that can be reused
 * in different calls. It will be enlarged automatically, when needed.
 * @ingroup utility_functions
 */
static MPI_Request *alloc_request_array(int count)
{
  static MPI_Request* local_req_arr = 0;
  static int          local_req_arr_size = 0;

  if (local_req_arr_size == 0)
  {
    /* -- never used: initialize -- */
    local_req_arr      = malloc(2 * count * sizeof(MPI_Request));
    local_req_arr_size = 2 * count;
  }
  else if (count > local_req_arr_size)
  {
    /* -- not enough room: expand -- */
    local_req_arr      = realloc(local_req_arr, count * sizeof(MPI_Request));
    local_req_arr_size = count;
  }
  return local_req_arr;
}

/**
 * Wrapper for a statically allocated status array that can be reused
 * in different calls. It will be enlarged automatically, when needed.
 * @ingroup utility_functions
 */
static MPI_Status *alloc_status_array(int count)
{
  static MPI_Status* local_stat_arr = 0;
  static int         local_stat_arr_size = 0;

  if (local_stat_arr_size == 0)
  {
    /* -- never used: initialize -- */
    local_stat_arr      = malloc(2 * count * sizeof(MPI_Status));
    local_stat_arr_size = 2 * count;
  } else if (count > local_stat_arr_size) {
    /* -- not enough room: expand -- */
    local_stat_arr      = realloc(local_stat_arr, count * sizeof(MPI_Status));
    local_stat_arr_size = count;
  }
  return local_stat_arr;
}

#if HAVE(DECL_PMPI_WAIT) && !defined(SILC_MPI_NO_P2P)
/**
 * Manual measurement wrapper for the Fortran interface of MPI_Wait,
 * when handle conversion is needed.
 * @ingroup manual_f2c_c2f_mpi_1_p2p
 */
void FSUB(MPI_Wait)(MPI_Fint *request,
                    MPI_Fint *status,
                    MPI_Fint *ierr)
{
  MPI_Request lrequest;
  MPI_Status  c_status;

  lrequest = MPI_Request_f2c(*request);
  *ierr    = MPI_Wait(&lrequest, &c_status);
  *request = MPI_Request_c2f(lrequest);
  
  if (*ierr == MPI_SUCCESS) 
  {
    MPI_Status_c2f(&c_status, status);
  }
}
#endif

#if HAVE(DECL_PMPI_WAITALL) && !defined(SILC_MPI_NO_P2P)
/**
 * Manual measurement wrapper for the Fortran interface of MPI_Waitall,
 * when handle conversion is needed.
 * @ingroup manual_f2c_c2f_mpi_1_p2p
 */
void FSUB(MPI_Waitall)(MPI_Fint* count,
                       MPI_Fint  array_of_requests[],
                       MPI_Fint  array_of_statuses[],
                       MPI_Fint* ierr)
{
  int          i;
  MPI_Request* lrequest = NULL;
  MPI_Status*  c_status = NULL;

  if (*count > 0)
  {
    lrequest = alloc_request_array(*count);
    c_status = alloc_status_array(*count);
    for (i=0; i<*count; i++) {
      lrequest[i] = MPI_Request_f2c(array_of_requests[i]);
    }
  }

  *ierr = MPI_Waitall(*count, lrequest, c_status);
  
  for (i=0; i < *count; i++)
  {
    array_of_requests[i] = MPI_Request_c2f(lrequest[i]);
  }
  if (*ierr == MPI_SUCCESS)
  {
    for (i=0; i<*count; i++)
    {
      MPI_Status_c2f(&(c_status[i]), &(array_of_statuses[i*silc_mpi_status_size]));
    }
  }
}
#endif

#if HAVE(DECL_PMPI_WAITANY) && !defined(SILC_MPI_NO_P2P)
/**
 * Manual measurement wrapper for the Fortran interface of MPI_Waitany,
 * when handle conversion is needed.
 * @note C index has to be converted to Fortran index, only if it is not
 *       MPI_UNDEFINED
 * @ingroup manual_f2c_c2f_mpi_1_p2p
 */
void FSUB(MPI_Waitany)(MPI_Fint* count,
                       MPI_Fint  array_of_requests[],
                       MPI_Fint* index,
                       MPI_Fint* status,
                       MPI_Fint* ierr)
{
  int          i;
  MPI_Request* lrequest = NULL;
  MPI_Status   c_status;

  if (*count > 0)
  {
    lrequest = alloc_request_array(*count);
    for (i=0; i<*count; i++)
    {
      lrequest[i] = MPI_Request_f2c(array_of_requests[i]);
    }
  }
  
  *ierr = MPI_Waitany(*count, lrequest, index, &c_status);
  
  if ((*ierr == MPI_SUCCESS) && (*index != MPI_UNDEFINED))
  {
    if (*index >= 0)
    {
      array_of_requests[*index] = MPI_Request_c2f(lrequest[*index]);
    
      /* See the description of waitany in the standard;
         the Fortran index ranges are from 1, not zero */
      (*index)++;
    }
    MPI_Status_c2f(&c_status, status);
  }
}
#endif

#if HAVE(DECL_PMPI_WAITSOME) && !defined(SILC_MPI_NO_P2P)
/**
 * Manual measurement wrapper for the Fortran interface of MPI_Waitsome,
 * when handle conversion is needed.
 * @note C indices have to be converted to Fortran indices, only if the
 *       outcount is not MPI_UNDEFINED
 * @ingroup manual_f2c_c2f_mpi_1_p2p
 */
void FSUB(MPI_Waitsome)(MPI_Fint* incount,
                        MPI_Fint  array_of_requests[],
                        MPI_Fint* outcount,
                        MPI_Fint  indices[],
                        MPI_Fint  array_of_statuses[],
                        MPI_Fint* ierr)
{
  int          i, j, found;
  MPI_Request* lrequest = NULL;
  MPI_Status*  c_status = NULL;

  /* get addresses of internal buffers, and convert input requests */
  if (*incount > 0)
  {
    lrequest = alloc_request_array(*incount);
    c_status = alloc_status_array(*incount);
    for (i=0; i<*incount; i++)
    {
      lrequest[i] = MPI_Request_f2c(array_of_requests[i]);
    }
  }

  /* call C wrapper function */
  *ierr = MPI_Waitsome(*incount, lrequest, outcount, indices, c_status); 
  
  /* convert requests and indices back to fortran */
  if ((*ierr == MPI_SUCCESS) && (*outcount != MPI_UNDEFINED))
  {
    for (i=0; i<*incount; i++)
    {
      if (i < *outcount)
      {
        if (indices[i] >= 0)
        {
          array_of_requests[indices[i]] = MPI_Request_c2f(lrequest[indices[i]]);
        }
      }
      else
      {
        found = j = 0;
        while ((!found) && (j<*outcount))
        {
          if (indices[j++] == i) found = 1;
        }
        
        if (!found)
        {
          array_of_requests[i] = MPI_Request_c2f(lrequest[i]);
        }
      }
    }
    for (i=0; i<*outcount; i++)
    {
      MPI_Status_c2f(&c_status[i], &(array_of_statuses[i*silc_mpi_status_size]));
      /* See the description of waitsome in the standard;
         the Fortran index ranges are from 1, not zero */
      if (indices[i] >= 0)
      {
        indices[i]++;
      }
    }
  }
}
#endif

#if HAVE(DECL_PMPI_TEST) && !defined(SILC_MPI_NO_P2P)
/**
 * Manual measurement wrapper for the Fortran interface of MPI_Test,
 * when handle conversion is needed.
 * @ingroup manual_f2c_c2f_mpi_1_p2p
 */
void FSUB(MPI_Test)(MPI_Fint* request,
                    MPI_Fint* flag,
                    MPI_Fint* status,
                    MPI_Fint* ierr)
{
  MPI_Status c_status;
  MPI_Request lrequest = MPI_Request_f2c(*request);

  *ierr = MPI_Test(&lrequest, flag, &c_status);
  if (*ierr != MPI_SUCCESS)
  {
    return;
  }
  *request = MPI_Request_c2f(lrequest);
  if (flag)
  {
    MPI_Status_c2f(&c_status, status);
  }
}
#endif

#if HAVE(DECL_PMPI_TESTANY) && !defined(SILC_MPI_NO_P2P)
/**
 * Manual measurement wrapper for the Fortran interface of MPI_Testany,
 * when handle conversion is needed.
 * @note C index has to be converted to Fortran index, only if it is not
 *       MPI_UNDEFINED
 * @ingroup manual_f2c_c2f_mpi_1_p2p
 */
void FSUB(MPI_Testany)(MPI_Fint* count,
                       MPI_Fint  array_of_requests[],
                       MPI_Fint* index,
                       MPI_Fint* flag,
                       MPI_Fint* status,
                       MPI_Fint* ierr)
{
  int          i;
  MPI_Request* lrequest = NULL;
  MPI_Status   c_status;

  if (*count > 0)
  {
    lrequest = alloc_request_array(*count);
    for (i=0; i<*count; i++)
    {
      lrequest[i] = MPI_Request_f2c(array_of_requests[i]);
    }
  }
  *ierr = MPI_Testany(*count, lrequest, index, flag, &c_status);
  if ((*ierr == MPI_SUCCESS) && (*index != MPI_UNDEFINED))
  {
    if (*flag && *index >= 0)
    {
      /* index may be MPI_UNDEFINED if all are null */
      array_of_requests[*index] = MPI_Request_c2f(lrequest[*index]);
    
      /* See the description of waitany in the standard;
         the Fortran index ranges are from 1, not zero */
      (*index)++;
    }
    MPI_Status_c2f(&c_status, status);
  }
}
#endif

#if HAVE(DECL_PMPI_TESTALL) && !defined(SILC_MPI_NO_P2P)
/**
 * Manual measurement wrapper for the Fortran interface of MPI_Testall,
 * when handle conversion is needed.
 * @note C indices have to be converted to Fortran indices
 * @ingroup manual_f2c_c2f_mpi_1_p2p
 */
void FSUB(MPI_Testall)(MPI_Fint* count,
                       MPI_Fint  array_of_requests[],
                       MPI_Fint* flag,
                       MPI_Fint  array_of_statuses[],
                       MPI_Fint *ierr)
{
  int          i;
  MPI_Request* lrequest = NULL;
  MPI_Status*  c_status = NULL;

  if (*count > 0)
  {
    lrequest = alloc_request_array(*count);
    c_status = alloc_status_array(*count);
    for (i=0; i<*count; i++)
    {
      lrequest[i] = MPI_Request_f2c(array_of_requests[i]);
    }
  }
  *ierr = MPI_Testall(*count, lrequest, flag, c_status);
  for (i=0; i<*count; i++)
  {
    array_of_requests[i] = MPI_Request_c2f(lrequest[i]);
  }
  if (*ierr == MPI_SUCCESS && *flag)
  {
    for (i=0; i<*count; i++)
    {
      MPI_Status_c2f(&(c_status[i]), &(array_of_statuses[i*silc_mpi_status_size]));
    }
  }
}
#endif

#if HAVE(DECL_PMPI_TESTSOME) && !defined(SILC_MPI_NO_P2P)
/**
 * Manual measurement wrapper for the Fortran interface of MPI_Testsome,
 * when handle conversion is needed.
 * @note C indices have to be converted to Fortran indices, only if the
 *       outcount is not MPI_UNDEFINED
 * @ingroup manual_f2c_c2f_mpi_1_p2p
 */
void FSUB(MPI_Testsome)(MPI_Fint* incount,
                        MPI_Fint  array_of_requests[],
                        MPI_Fint* outcount,
                        MPI_Fint  indices[],
                        MPI_Fint  array_of_statuses[],
                        MPI_Fint* ierr)
{
  int          i, j, found;
  MPI_Request* lrequest = NULL;
  MPI_Status*  c_status = NULL;

  if (*incount > 0)
  {
    lrequest = alloc_request_array(*incount);
    c_status = alloc_status_array(*incount);
    for (i=0; i<*incount; i++)
    {
      lrequest[i] = MPI_Request_f2c(array_of_requests[i]);
    }
  }

  *ierr = MPI_Testsome(*incount, lrequest, outcount, indices, c_status); 
  
  if ((*ierr == MPI_SUCCESS) && (*outcount != MPI_UNDEFINED))
  {
    for (i=0; i<*incount; i++)
    {
      if (i < *outcount)
      {
        array_of_requests[indices[i]] = MPI_Request_c2f(lrequest[indices[i]]);
      }
      else
      {
        found = j = 0;
        while ( (!found) && (j<*outcount) )
        {
          if (indices[j++] == i) found = 1;
        }
        if (!found)
        {
          array_of_requests[i] = MPI_Request_c2f(lrequest[i]);
        }
      }
    }
    for (i=0; i<*outcount; i++)
    {
      MPI_Status_c2f(&c_status[i], &(array_of_statuses[i*silc_mpi_status_size]));
      /* See the description of testsome in the standard;
         the Fortran index ranges are from 1, not zero */
      if (indices[i] >= 0)
      {
        indices[i]++;
      }
    }
  }
}
#endif

#if HAVE(DECL_PMPI_STARTALL) && !defined(SILC_MPI_NO_P2P)
/**
 * Manual measurement wrapper for the Fortran interface of MPI_Startall,
 * when handle conversion is needed.
 * @ingroup manual_f2c_c2f_mpi_1_p2p
 */
void FSUB(MPI_Startall)(MPI_Fint* count,
                        MPI_Fint  array_of_requests[],
                        MPI_Fint* ierr)
{
  int          i;
  MPI_Request* lrequest = NULL;

  if (*count > 0)
  {
    lrequest = alloc_request_array(*count);
    for (i=0; i<*count; i++)
    {
      lrequest[i] = MPI_Request_f2c(array_of_requests[i]);
    }
  }

  *ierr = MPI_Startall(*count, lrequest);
  
  if (*ierr == MPI_SUCCESS)
  {
    for (i=0; i<*count; i++)
    {
      array_of_requests[i] = MPI_Request_c2f(lrequest[i]);
    }
  }
}
#endif

#if HAVE(DECL_PMPI_REQUEST_FREE) && !defined(SILC_MPI_NO_P2P)
/**
 * Manual measurement wrapper for the Fortran interface of MPI_Testall,
 * when handle conversion is needed.
 * @ingroup manual_f2c_c2f_mpi_1_p2p
 */
void FSUB(MPI_Request_free)(MPI_Fint* request,
                            MPI_Fint* ierr)
{
  MPI_Request lrequest = MPI_Request_f2c(*request);

  *ierr = MPI_Request_free(&lrequest);
  
  if (*ierr == MPI_SUCCESS)
  {
    *request = MPI_Request_c2f(lrequest);
  }
}
#endif

#if HAVE(DECL_PMPI_CANCEL) && !defined(SILC_MPI_NO_P2P)
/**
 * Manual measurement wrapper for the Fortran interface of MPI_Testall,
 * when handle conversion is needed.
 * @note C indices have to be converted to Fortran indices, when the
 *       effective index is not MPI_UNDEFINED
 * @ingroup manual_f2c_c2f_mpi_1_p2p
 */
void FSUB(MPI_Cancel)(MPI_Fint *request,
                      MPI_Fint *ierr)
{
  MPI_Request lrequest;

  lrequest = MPI_Request_f2c(*request);  
  *ierr = MPI_Cancel(&lrequest); 
}
#endif

#pragma wrapgen multiple restrict(gp2p+!nWait+!nTest+!nStartall+!nRequest_free+!nCancel) skel/SILC_Mpi_F2c_C2f.w

#endif
