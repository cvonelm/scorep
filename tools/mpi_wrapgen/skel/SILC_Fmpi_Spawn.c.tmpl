/****************************************************************************
**  SCALASCA    http://www.scalasca.org/                                   **
**  KOJAK       http://www.fz-juelich.de/jsc/kojak/                        **
*****************************************************************************
**  Copyright (c) 1998-2009                                                **
**  Forschungszentrum Juelich, Juelich Supercomputing Centre               **
**                                                                         **
**  Copyright (c) 2003-2008                                                **
**  University of Tennessee, Innovative Computing Laboratory               **
**                                                                         **
**  See the file COPYRIGHT in the package base directory for details       **
****************************************************************************/

/**
 * @file  SILC_Fmpi_Spawn.c
 *
 * @brief Fortran interface wrappers for process creation and management 
 *        functions (spawning interface)
 */

/* uppercase defines */
#pragma wrapgen multiple restrict(gspawn) skel/SILC_Fmpi_DefineU.w

/* lowercase defines */
#pragma wrapgen multiple restrict(gspawn) skel/SILC_Fmpi_DefineL.w

/**
 * @name Fortran wrappers 
 * @{
 */

#ifndef NEED_F2C_CONV

/* If MPI_Comm_f2c is defined as a simple macro (which typically does nothing)
 * as it would require a "real" function if it is really needed
 * => we can save the f2c and c2s conversions */

/**
 * Manual measurement wrapper for MPI_Comm_spawn_multiple
 * @ingroup manual_wrapper
 * @ingroup interface_fortran
 * @ingroup mpi_version_2
 * @ingroup mpi_enabled_proc
 */
void FSUB(MPI_Comm_spawn_multiple)(MPI_Fint* count,
                                   char* array_of_commands[],
                                   char* array_of_argv[],
                                   MPI_Fint* array_of_maxprocs,
                                   MPI_Fint* array_of_info,
                                   MPI_Fint* root,
                                   MPI_Fint* comm,
                                   MPI_Fint* intercomm,
                                   MPI_Fint* array_of_errcodes,
                                   MPI_Fint* ierr,
                                   MPI_Fint array_of_commands_len[])
{
  MPI_Fint  i;
  char*     c_array_of_commands[] = NULL;
  char*     c_array_of_argv[]     = NULL;

  /* allocate and fill local array_of_commands */
  c_array_of_commands = (char**)malloc(count * sizeof (char*));
  if (!c_array_of_commands) { exit(EXIT_FAILURE); }
  for (i = 0; i < count; ++i)
  {
    c_array_of_commands[i] =
        (char*)malloc((array_of_commands_len[i] + 1) * sizeof (char));
    if (!(c_array_of_commands[i])) { exit(EXIT_FAILURE); }
    strncpy(c_array_of_commands[i], array_of_commands[i],
            array_of_commands_len[i]);
    /* null terminate character array */
    c_array_of_commands[i][array_of_commands_len[i]] = '\0';
  }

  /* allocate and fill local array_of_argv */
  c_array_of_argv = (char**)malloc(count * sizeof (char*));
  if (!c_array_of_argv) { exit(EXIT_FAILURE); }
  for (i = 0; i < count; ++i)
  {
    c_array_of_argv[i] =
        (char*)malloc((array_of_argv_len[i] + 1) * sizeof (char));
    if (!(c_array_of_argv[i])) { exit(EXIT_FAILURE); }
    strncpy(c_array_of_argv[i], array_of_argv[i],
            array_of_argv_len[i]);
    /* null terminate character array */
    c_array_of_argv[i][array_of_argv_len[i]] = '\0';
  }

  *ierr = MPI_Comm_spawn_multiple(*count, c_array_of_commands, 
                                  c_array_of_argv, array_of_maxprocs, 
                                  array_of_info, *root, *comm, 
                                  intercomm, array_of_errcodes);

  for (i = 0; i < count; ++i)
  {
    free(c_array_of_commands[i]);
    free(c_array_of_argv[i]);
  }
  free(c_array_of_commands);
  free(c_array_of_argv);
}

#pragma wrapgen multiple restrict(gspawn+!nspawn_multiple) skel/SILC_Fmpi_Std.w

#else /* !NEED_F2C_CONV */

/**
 * Manual measurement wrapper for MPI_Comm_spawn_multiple
 * @ingroup manual_wrapper
 * @ingroup interface_fortran
 * @ingroup mpi_version_2
 * @ingroup mpi_enabled_proc
 */
void FSUB(MPI_Comm_spawn_multiple) (MPI_Fint* count,
                                    char* array_of_commands[],
                                    char* array_of_argv[],
                                    MPI_Fint* array_of_maxprocs,
                                    MPI_Fint* array_of_info,
                                    MPI_Fint* root,
                                    MPI_Fint* comm,
                                    MPI_Fint* intercomm,
                                    MPI_Fint* array_of_errcodes,
                                    MPI_Fint* ierr,
                                    MPI_Fint array_of_commands_len[])
{
  MPI_Fint  i;
  char*     c_array_of_commands[] = NULL;
  char*     c_array_of_argv[]     = NULL;
  MPI_Info* c_array_of_info       = NULL;

  /* allocate and fill local array_of_commands */
  c_array_of_commands = (char**)malloc(count * sizeof (char*));
  if (!c_array_of_commands) { exit(EXIT_FAILURE); }
  for (i = 0; i < count; ++i)
  {
    c_array_of_commands[i] =
        (char*)malloc((array_of_commands_len[i] + 1) * sizeof (char));
    if (!(c_array_of_commands[i])) { exit(EXIT_FAILURE); }
    strncpy(c_array_of_commands[i], array_of_commands[i],
            array_of_commands_len[i]);
    /* null terminate character array */
    c_array_of_commands[i][array_of_commands_len[i]] = '\0';
  }

  /* allocate and fill local array_of_argv */
  c_array_of_argv = (char**)malloc(count * sizeof (char*));
  if (!c_array_of_argv) { exit(EXIT_FAILURE); }
  for (i = 0; i < count; ++i)
  {
    c_array_of_argv[i] =
        (char*)malloc((array_of_argv_len[i] + 1) * sizeof (char));
    if (!(c_array_of_argv[i])) { exit(EXIT_FAILURE); }
    strncpy(c_array_of_argv[i], array_of_argv[i],
            array_of_argv_len[i]);
    /* null terminate character array */
    c_array_of_argv[i][array_of_argv_len[i]] = '\0';
  }

  /* allocate and fill local array_of_info */
  c_array_of_info = (MPI_Info*)malloc(count * sizeof (MPI_Info));
  if (!(c_array_of_info)) { exit(EXIT_FAILURE); }
  for (i = 0; i < count; ++i)
  {
    c_array_of_info = PMPI_Info_f2c(array_of_info[i]);
  }

  *ierr = MPI_Comm_spawn_multiple(*count, c_array_of_commands, 
                                  c_array_of_argv, array_of_maxprocs, 
                                  c_array_of_info, *root, *comm, 
                                  intercomm, array_of_errcodes);

  for (i = 0; i < count; ++i)
  {
    free(c_array_of_commands[i]);
    free(c_array_of_argv[i]);
  }
  free(c_array_of_commands);
  free(c_array_of_argv);
  free(c_array_of_info);
}

#pragma wrapgen multiple restrict(gspawn+!nspawn_multiple) skel/SILC_Mpi_F2c_C2f.w

#endif

/**
 * @}
 */
