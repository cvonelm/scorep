
/**
 * @file  SILC_Fmpi_Spawn.c
 * @maintainer Daniel Lorenz <d.lorenz@fz-juelich.de>
 * @status     ALPHA
 * @ingroup    MPI_Wrapper
 *
 * @brief Fortran interface wrappers for process creation and management 
 *        functions (spawning interface)
 */

#include "SILC_Fmpi.h"
#include "config.h"

/* uppercase defines */
#pragma wrapgen multiple restrict(gspawn) skel/SILC_Fmpi_DefineU.w

/* lowercase defines */
#pragma wrapgen multiple restrict(gspawn) skel/SILC_Fmpi_DefineL.w

/**
 * @name Fortran wrappers 
 * @{
 */

#ifndef NEED_F2C_CONV

/* If MPI_Comm_f2c is HAVE as a simple macro (which typically does nothing)
 * as it would require a "real" function if it is really needed
 * => we can save the f2c and c2s conversions */

#if HAVE(DECL_MPI_COMM_SPAWN_MULTIPLE) && ! defined(SILC_MPI_NO_SPAWN) && ! defined(SILC_MPI_NO_EXTRA)
/**
 * Manual measurement wrapper for MPI_Comm_spawn_multiple
 * @ingroup manual_wrapper
 * @ingroup interface_fortran
 * @ingroup mpi_version_2
 * @ingroup mpi_enabled_proc
 */
void FSUB(MPI_Comm_spawn_multiple)(MPI_Fint* count,
                                   char* array_of_commands[],
                                   char* array_of_argv[],
                                   MPI_Fint* array_of_maxprocs,
                                   MPI_Fint* array_of_info,
                                   MPI_Fint* root,
                                   MPI_Fint* comm,
                                   MPI_Fint* intercomm,
                                   MPI_Fint* array_of_errcodes,
                                   MPI_Fint* ierr,
                                   MPI_Fint array_of_commands_len[],
                                   MPI_Fint array_of_argv_len[])
{
  MPI_Fint  i;
  char**    c_array_of_commands = NULL;
  char**    c_array_of_argv     = NULL;

  /* allocate and fill local array_of_commands */
  c_array_of_commands = (char**)malloc(*count * sizeof (char*));
  if (!c_array_of_commands) 
  { 
    exit(EXIT_FAILURE); 
  }
  for (i = 0; i < *count; ++i)
  {
    c_array_of_commands[i] =
        (char*)malloc((array_of_commands_len[i] + 1) * sizeof (char));
    if (!(c_array_of_commands[i])) 
    { 
      exit(EXIT_FAILURE); 
    }
    strncpy(c_array_of_commands[i], array_of_commands[i],
            array_of_commands_len[i]);
    /* null terminate character array */
    c_array_of_commands[i][array_of_commands_len[i]] = '\0';
  }

  /* allocate and fill local array_of_argv */
  c_array_of_argv = (char**)malloc(*count * sizeof (char*));
  if (!c_array_of_argv) 
  { 
    exit(EXIT_FAILURE); 
  }
  for (i = 0; i < *count; ++i)
  {
    c_array_of_argv[i] =
        (char*)malloc((array_of_argv_len[i] + 1) * sizeof (char));
    if (!(c_array_of_argv[i])) 
    { 
      exit(EXIT_FAILURE); 
    }
    strncpy(c_array_of_argv[i], array_of_argv[i],
            array_of_argv_len[i]);
    /* null terminate character array */
    c_array_of_argv[i][array_of_argv_len[i]] = '\0';
  }

  *ierr = MPI_Comm_spawn_multiple(*count, c_array_of_commands, 
                                  c_array_of_argv, array_of_maxprocs, 
                                  array_of_info, *root, *comm, 
                                  intercomm, array_of_errcodes);

  for (i = 0; i < *count; ++i)
  {
    free(c_array_of_commands[i]);
    free(c_array_of_argv[i]);
  }
  free(c_array_of_commands);
  free(c_array_of_argv);
}
#endif

#pragma wrapgen multiple restrict(gspawn+!nspawn_multiple) skel/SILC_Fmpi_Std.w

#else /* !NEED_F2C_CONV */

#if HAVE(DECL_MPI_COMM_SPAWN_MULTIPLE) && ! defined(SILC_MPI_NO_SPAWN) && ! defined(SILC_MPI_NO_EXTRA)
/**
 * Manual measurement wrapper for MPI_Comm_spawn_multiple
 * @ingroup manual_wrapper
 * @ingroup interface_fortran
 * @ingroup mpi_version_2
 * @ingroup mpi_enabled_proc
 */
void FSUB(MPI_Comm_spawn_multiple) (MPI_Fint* count,
                                    char* array_of_commands[],
                                    char* array_of_argv[],
                                    MPI_Fint* array_of_maxprocs,
                                    MPI_Fint* array_of_info,
                                    MPI_Fint* root,
                                    MPI_Fint* comm,
                                    MPI_Fint* intercomm,
                                    MPI_Fint* array_of_errcodes,
                                    MPI_Fint* ierr,
                                    MPI_Fint array_of_commands_len[])
{
  MPI_Fint  i;
  char**    c_array_of_commands   = NULL;
  char**    c_array_of_argv       = NULL;
  MPI_Info* c_array_of_info       = NULL;

  /* allocate and fill local array_of_commands */
  c_array_of_commands = (char**)malloc(count * sizeof (char*));
  if (!c_array_of_commands) { exit(EXIT_FAILURE); }
  for (i = 0; i < count; ++i)
  {
    c_array_of_commands[i] =
        (char*)malloc((array_of_commands_len[i] + 1) * sizeof (char));
    if (!(c_array_of_commands[i])) { exit(EXIT_FAILURE); }
    strncpy(c_array_of_commands[i], array_of_commands[i],
            array_of_commands_len[i]);
    /* null terminate character array */
    c_array_of_commands[i][array_of_commands_len[i]] = '\0';
  }

  /* allocate and fill local array_of_argv */
  c_array_of_argv = (char**)malloc(count * sizeof (char*));
  if (!c_array_of_argv) { exit(EXIT_FAILURE); }
  for (i = 0; i < count; ++i)
  {
    c_array_of_argv[i] =
        (char*)malloc((array_of_argv_len[i] + 1) * sizeof (char));
    if (!(c_array_of_argv[i])) { exit(EXIT_FAILURE); }
    strncpy(c_array_of_argv[i], array_of_argv[i],
            array_of_argv_len[i]);
    /* null terminate character array */
    c_array_of_argv[i][array_of_argv_len[i]] = '\0';
  }

  /* allocate and fill local array_of_info */
  c_array_of_info = (MPI_Info*)malloc(count * sizeof (MPI_Info));
  if (!(c_array_of_info)) { exit(EXIT_FAILURE); }
  for (i = 0; i < count; ++i)
  {
    c_array_of_info = PMPI_Info_f2c(array_of_info[i]);
  }

  *ierr = MPI_Comm_spawn_multiple(*count, c_array_of_commands, 
                                  c_array_of_argv, array_of_maxprocs, 
                                  c_array_of_info, *root, *comm, 
                                  intercomm, array_of_errcodes);

  for (i = 0; i < count; ++i)
  {
    free(c_array_of_commands[i]);
    free(c_array_of_argv[i]);
  }
  free(c_array_of_commands);
  free(c_array_of_argv);
  free(c_array_of_info);
}
#endif

#pragma wrapgen multiple restrict(gspawn+!nspawn_multiple) skel/SILC_Mpi_F2c_C2f.w

#endif

/**
 * @}
 */
