/**
 * @file SILC_Mpi_Reg.c
 *
 * @brief Registration of MPI regions
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>

#include "SILC_Mpi.h"
#include "config.h"

#define SILC_REGION_MPI SILC_REGION_FUNCTION

/** 
 * MPI operation event type 
 */
typedef struct
{
  char*    name;
  uint32_t type;
} silc_mpi_type;

/** MPI point-to-point function types
 * @note contents must be alphabetically sorted */
static const silc_mpi_type silc_mpi_pt2pt[] = {
  { "MPI_Bsend",            SILC_MPI_TYPE__SEND },
  { "MPI_Ibsend",           SILC_MPI_TYPE__SEND },
  { "MPI_Irsend",           SILC_MPI_TYPE__SEND },
  { "MPI_Isend",            SILC_MPI_TYPE__SEND },
  { "MPI_Issend",           SILC_MPI_TYPE__SEND },
  { "MPI_Recv",                                   SILC_MPI_TYPE__RECV },
  { "MPI_Rsend",            SILC_MPI_TYPE__SEND },
  { "MPI_Send",             SILC_MPI_TYPE__SEND },
  { "MPI_Sendrecv",         SILC_MPI_TYPE__SEND & SILC_MPI_TYPE__RECV },
  { "MPI_Sendrecv_replace", SILC_MPI_TYPE__SEND & SILC_MPI_TYPE__RECV },
  { "MPI_Ssend",            SILC_MPI_TYPE__SEND },
  { "MPI_Start",            SILC_MPI_TYPE__SEND },
  { "MPI_Startall",         SILC_MPI_TYPE__SEND },
  { "MPI_Test",                                  SILC_MPI_TYPE__RECV },
  { "MPI_Testall",                               SILC_MPI_TYPE__RECV },
  { "MPI_Testany",                               SILC_MPI_TYPE__RECV },
  { "MPI_Testsome",                              SILC_MPI_TYPE__RECV },
  { "MPI_Wait",                                  SILC_MPI_TYPE__RECV },
  { "MPI_Waitall",                               SILC_MPI_TYPE__RECV },
  { "MPI_Waitany",                               SILC_MPI_TYPE__RECV },
  { "MPI_Waitsome",                              SILC_MPI_TYPE__RECV },
};

/** MPI collective function types 
 * @note contents must be alphabetically sorted */
static const silc_mpi_type silc_mpi_colls[] = {
  { "MPI_Allgather",      SILC_COLL_TYPE__ALL2ALL },
  { "MPI_Allgatherv",     SILC_COLL_TYPE__ALL2ALL },
  { "MPI_Allreduce",      SILC_COLL_TYPE__ALL2ALL },
  { "MPI_Alltoall",       SILC_COLL_TYPE__ALL2ALL },
  { "MPI_Alltoallv",      SILC_COLL_TYPE__ALL2ALL },
  { "MPI_Alltoallw",      SILC_COLL_TYPE__ALL2ALL },
  { "MPI_Barrier",        SILC_COLL_TYPE__BARRIER },
  { "MPI_Bcast",          SILC_COLL_TYPE__ONE2ALL },
  { "MPI_Cart_create",    SILC_COLL_TYPE__IMPLIED },
  { "MPI_Cart_sub",       SILC_COLL_TYPE__IMPLIED },
  { "MPI_Comm_create",    SILC_COLL_TYPE__IMPLIED },
  { "MPI_Comm_dup",       SILC_COLL_TYPE__IMPLIED },
  { "MPI_Comm_free",      SILC_COLL_TYPE__IMPLIED },
  { "MPI_Comm_split",     SILC_COLL_TYPE__IMPLIED },
  { "MPI_Exscan",         SILC_COLL_TYPE__PARTIAL },
  { "MPI_Finalize",       SILC_COLL_TYPE__IMPLIED },
  { "MPI_Gather",         SILC_COLL_TYPE__ALL2ONE },
  { "MPI_Gatherv",        SILC_COLL_TYPE__ALL2ONE },
  { "MPI_Init",           SILC_COLL_TYPE__IMPLIED },
  { "MPI_Init_thread",    SILC_COLL_TYPE__IMPLIED },
  { "MPI_Reduce",         SILC_COLL_TYPE__ALL2ONE },
  { "MPI_Reduce_scatter", SILC_COLL_TYPE__ALL2ALL },
  { "MPI_Scan",           SILC_COLL_TYPE__PARTIAL },
  { "MPI_Scatter",        SILC_COLL_TYPE__ONE2ALL },
  { "MPI_Scatterv",       SILC_COLL_TYPE__ONE2ALL },
  { "MPI_Win_create",     SILC_COLL_TYPE__IMPLIED },
  { "MPI_Win_fence",      SILC_COLL_TYPE__IMPLIED },
  { "MPI_Win_free",       SILC_COLL_TYPE__IMPLIED }
};

/** Region IDs of MPI functions */
SILC_RegionHandle silc_mpi_regid[SILC__MPI_NUMFUNCS+1];

/** Mapping of string keys to enabling group IDs 
 * @note The keys need to be alphabetically sorted, to enable binary
 *       search on the data structure.
 */
static const silc_mpi_type silc_mpi_enable_groups[] = {
  { "ALL",     SILC_MPI_ENABLED_ALL     },
  { "CG",      SILC_MPI_ENABLED_CG      },
  { "COLL",    SILC_MPI_ENABLED_COLL    },
  { "DEFAULT", SILC_MPI_ENABLED_DEFAULT },
  { "ENV",     SILC_MPI_ENABLED_ENV     },
  { "ERR",     SILC_MPI_ENABLED_ERR     },
  { "EXT",     SILC_MPI_ENABLED_EXT     },
  { "IO",      SILC_MPI_ENABLED_IO      },
  { "MISC",    SILC_MPI_ENABLED_MISC    },
  { "P2P",     SILC_MPI_ENABLED_P2P     },
  { "RMA",     SILC_MPI_ENABLED_RMA     },
  { "SPAWN",   SILC_MPI_ENABLED_SPAWN   },
  { "TOPO",    SILC_MPI_ENABLED_TOPO    },
  { "TYPE",    SILC_MPI_ENABLED_TYPE    }
};

/** Bit vector for runtime measurement wrapper enabling/disabling */
uint32_t silc_mpi_enabled = 0;

extern char **silc_mpi_config_groups;

static int silc_mpi_mycmp(const void *v1, const void *v2);

void
silc_mpi_evaluate_config()
{
  char **groups = silc_mpi_config_groups;
 
  /* If config not set, enable default configuration */
  if (*groups == NULL)
  {
    silc_mpi_enabled = SILC_MPI_ENABLED_DEFAULT;
    return;
  }

  /* Add every entry */
  while(*groups != NULL)
  {
    /* check if token is a valid flag */
    silc_mpi_type* match =
            bsearch(*groups, (silc_mpi_type*)silc_mpi_enable_groups,
                    sizeof(silc_mpi_enable_groups)/sizeof(silc_mpi_type),
                    sizeof(silc_mpi_type), silc_mpi_mycmp);

    if (match)
    {
      /* enable event generation for function group */
      silc_mpi_enabled |= match->type;
      SILC_DEBUG_PRINTF(SILC_DEBUG_MPI, 
                        "Enabled event generation for MPI group: %s", *groups);
    }
    else
    {
        /* token is not a valid MPI function group */
        SILC_DEBUG_PRINTF(SILC_WARNING | SILC_DEBUG_MPI, 
                          "Unknown MPI function group ignored: %s", *groups);
    }
    groups ++;
  }
}

/**
 * Register MPI functions and initialize data structures
 */
void silc_mpi_register_regions()
{
  SILC_SourceFileHandle file_id = SILC_DefineSourceFile("MPI");
 
  silc_mpi_evaluate_config();

#pragma wrapgen multiple restrict() skel/SILC_Mpi_RegC.w

  /* Artificial root for MPI-only experiments when no user-code
   * instrumenation is available */
  silc_mpi_regid[SILC_PARALLEL__MPI] =
      SILC_DefineRegion("PARALLEL", SILC_INVALID_SOURCE_FILE, SILC_INVALID_LINE_NO, 
                        SILC_INVALID_LINE_NO, SILC_ADAPTER_MPI, SILC_REGION_UNKNOWN);
}

/**
 * Compare function for binary search
 * @param v1 string to checked
 * @param v2 pointer to \p silc_mpi_type structure
 * @return result is equivalent to \p strcasecmp result of two strings
 */
static int silc_mpi_mycmp(const void *v1, const void *v2)
{
   return strcasecmp((char*)v1, ((silc_mpi_type*)v2)->name);
}

/**
 * Check if region is flagged \a collective
 * @param str Region name
 * @return type of function if collective, 0 otherwise.
 */
uint8_t silc_is_mpi_collective(const char* str)
{
  silc_mpi_type * match =
    bsearch(str, (silc_mpi_type*)silc_mpi_colls, sizeof(silc_mpi_colls)/sizeof(silc_mpi_type),
	    sizeof(silc_mpi_type), silc_mpi_mycmp);

  return match ? match->type : 0;
}

/**
 * Check if region is flagged \a point-to-point
 * @param str Region name
 * @return type of function if point-to-point, 0 otherwise.
 */
uint8_t silc_is_mpi_point2point(const char* str)
{
  silc_mpi_type * match =
    bsearch(str, (silc_mpi_type*)silc_mpi_pt2pt, sizeof(silc_mpi_pt2pt)/sizeof(silc_mpi_type),
	    sizeof(silc_mpi_type), silc_mpi_mycmp);

  return match ? match->type : SILC_MPI_TYPE__NONE;
}

/**
 * Check if region is flagged either \a point-to-point or \a collective
 * @param  str Region name
 * @return type of function, if point-to-point or collective. 0,
 *         otherwise.
 */
uint8_t silc_mpi_eventtype(const char* str)
{
  uint8_t type = silc_is_mpi_point2point(str);
  if (type != SILC_MPI_TYPE__NONE)
      return type;

  type = (uint8_t) silc_is_mpi_collective(str);
  switch (type) {
      case SILC_COLL_TYPE__BARRIER:
      case SILC_COLL_TYPE__ONE2ALL:
      case SILC_COLL_TYPE__ALL2ONE:
      case SILC_COLL_TYPE__ALL2ALL:
      case SILC_COLL_TYPE__PARTIAL:
          return SILC_MPI_TYPE__COLLECTIVE;
      default:
          break;
  }
  return SILC_MPI_TYPE__NONE;
}
