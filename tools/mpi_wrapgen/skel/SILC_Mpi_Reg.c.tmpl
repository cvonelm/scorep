/**
 * @file SILC_Mpi_Reg.c
 * @maintainer Daniel Lorenz <d.lorenz@fz-juelich.de>
 * @status     ALPHA
 * @ingroup    MPI_Wrapper
 *
 * @brief Registration of MPI regions
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>

#include "SILC_Mpi.h"
#include "config.h"

#define SILC_REGION_MPI SILC_REGION_FUNCTION

/** 
 * MPI operation event type 
 */
typedef struct
{
  char*    name;
  uint32_t type;
} silc_mpi_type;

/** MPI point-to-point function types
 * @note contents must be alphabetically sorted */
static const silc_mpi_type silc_mpi_pt2pt[] = {
  { "MPI_Bsend",            SILC_MPI_TYPE__SEND },
  { "MPI_Ibsend",           SILC_MPI_TYPE__SEND },
  { "MPI_Irsend",           SILC_MPI_TYPE__SEND },
  { "MPI_Isend",            SILC_MPI_TYPE__SEND },
  { "MPI_Issend",           SILC_MPI_TYPE__SEND },
  { "MPI_Recv",                                   SILC_MPI_TYPE__RECV },
  { "MPI_Rsend",            SILC_MPI_TYPE__SEND },
  { "MPI_Send",             SILC_MPI_TYPE__SEND },
  { "MPI_Sendrecv",         SILC_MPI_TYPE__SEND & SILC_MPI_TYPE__RECV },
  { "MPI_Sendrecv_replace", SILC_MPI_TYPE__SEND & SILC_MPI_TYPE__RECV },
  { "MPI_Ssend",            SILC_MPI_TYPE__SEND },
  { "MPI_Start",            SILC_MPI_TYPE__SEND },
  { "MPI_Startall",         SILC_MPI_TYPE__SEND },
  { "MPI_Test",                                  SILC_MPI_TYPE__RECV },
  { "MPI_Testall",                               SILC_MPI_TYPE__RECV },
  { "MPI_Testany",                               SILC_MPI_TYPE__RECV },
  { "MPI_Testsome",                              SILC_MPI_TYPE__RECV },
  { "MPI_Wait",                                  SILC_MPI_TYPE__RECV },
  { "MPI_Waitall",                               SILC_MPI_TYPE__RECV },
  { "MPI_Waitany",                               SILC_MPI_TYPE__RECV },
  { "MPI_Waitsome",                              SILC_MPI_TYPE__RECV },
};

/** MPI collective function types 
 * @note contents must be alphabetically sorted */
static const silc_mpi_type silc_mpi_colls[] = {
  { "MPI_Allgather",      SILC_COLL_TYPE__ALL2ALL },
  { "MPI_Allgatherv",     SILC_COLL_TYPE__ALL2ALL },
  { "MPI_Allreduce",      SILC_COLL_TYPE__ALL2ALL },
  { "MPI_Alltoall",       SILC_COLL_TYPE__ALL2ALL },
  { "MPI_Alltoallv",      SILC_COLL_TYPE__ALL2ALL },
  { "MPI_Alltoallw",      SILC_COLL_TYPE__ALL2ALL },
  { "MPI_Barrier",        SILC_COLL_TYPE__BARRIER },
  { "MPI_Bcast",          SILC_COLL_TYPE__ONE2ALL },
  { "MPI_Cart_create",    SILC_COLL_TYPE__IMPLIED },
  { "MPI_Cart_sub",       SILC_COLL_TYPE__IMPLIED },
  { "MPI_Comm_create",    SILC_COLL_TYPE__IMPLIED },
  { "MPI_Comm_dup",       SILC_COLL_TYPE__IMPLIED },
  { "MPI_Comm_free",      SILC_COLL_TYPE__IMPLIED },
  { "MPI_Comm_split",     SILC_COLL_TYPE__IMPLIED },
  { "MPI_Exscan",         SILC_COLL_TYPE__PARTIAL },
  { "MPI_Finalize",       SILC_COLL_TYPE__IMPLIED },
  { "MPI_Gather",         SILC_COLL_TYPE__ALL2ONE },
  { "MPI_Gatherv",        SILC_COLL_TYPE__ALL2ONE },
  { "MPI_Init",           SILC_COLL_TYPE__IMPLIED },
  { "MPI_Init_thread",    SILC_COLL_TYPE__IMPLIED },
  { "MPI_Reduce",         SILC_COLL_TYPE__ALL2ONE },
  { "MPI_Reduce_scatter", SILC_COLL_TYPE__ALL2ALL },
  { "MPI_Scan",           SILC_COLL_TYPE__PARTIAL },
  { "MPI_Scatter",        SILC_COLL_TYPE__ONE2ALL },
  { "MPI_Scatterv",       SILC_COLL_TYPE__ONE2ALL },
  { "MPI_Win_create",     SILC_COLL_TYPE__IMPLIED },
  { "MPI_Win_fence",      SILC_COLL_TYPE__IMPLIED },
  { "MPI_Win_free",       SILC_COLL_TYPE__IMPLIED }
};

/** Region IDs of MPI functions */
SILC_RegionHandle silc_mpi_regid[SILC__MPI_NUMFUNCS+1];

/** Bit vector for runtime measurement wrapper enabling/disabling */
uint64_t silc_mpi_enabled = 0;

/**
 * Register MPI functions and initialize data structures
 */
void silc_mpi_register_regions()
{
  SILC_SourceFileHandle file_id = SILC_DefineSourceFile("MPI");
 
#pragma wrapgen multiple restrict() skel/SILC_Mpi_RegC.w

  /* Artificial root for MPI-only experiments when no user-code
   * instrumenation is available */
  silc_mpi_regid[SILC_PARALLEL__MPI] =
      SILC_DefineRegion("PARALLEL", SILC_INVALID_SOURCE_FILE, SILC_INVALID_LINE_NO, 
                        SILC_INVALID_LINE_NO, SILC_ADAPTER_MPI, SILC_REGION_UNKNOWN);
}

/**
 * Compare function for binary search
 * @param v1 string to checked
 * @param v2 pointer to \p silc_mpi_type structure
 * @return result is equivalent to \p strcasecmp result of two strings
 */
static int silc_mpi_mycmp(const void *v1, const void *v2)
{
   return strcasecmp((char*)v1, ((silc_mpi_type*)v2)->name);
}

/**
 * Check if region is flagged \a collective
 * @param str Region name
 * @return type of function if collective, 0 otherwise.
 */
uint8_t silc_is_mpi_collective(const char* str)
{
  silc_mpi_type * match =
    bsearch(str, (silc_mpi_type*)silc_mpi_colls, sizeof(silc_mpi_colls)/sizeof(silc_mpi_type),
	    sizeof(silc_mpi_type), silc_mpi_mycmp);

  return match ? match->type : 0;
}

/**
 * Check if region is flagged \a point-to-point
 * @param str Region name
 * @return type of function if point-to-point, 0 otherwise.
 */
uint8_t silc_is_mpi_point2point(const char* str)
{
  silc_mpi_type * match =
    bsearch(str, (silc_mpi_type*)silc_mpi_pt2pt, sizeof(silc_mpi_pt2pt)/sizeof(silc_mpi_type),
	    sizeof(silc_mpi_type), silc_mpi_mycmp);

  return match ? match->type : SILC_MPI_TYPE__NONE;
}

/**
 * Check if region is flagged either \a point-to-point or \a collective
 * @param  str Region name
 * @return type of function, if point-to-point or collective. 0,
 *         otherwise.
 */
uint8_t silc_mpi_eventtype(const char* str)
{
  uint8_t type = silc_is_mpi_point2point(str);
  if (type != SILC_MPI_TYPE__NONE)
      return type;

  type = (uint8_t) silc_is_mpi_collective(str);
  switch (type) {
      case SILC_COLL_TYPE__BARRIER:
      case SILC_COLL_TYPE__ONE2ALL:
      case SILC_COLL_TYPE__ALL2ONE:
      case SILC_COLL_TYPE__ALL2ALL:
      case SILC_COLL_TYPE__PARTIAL:
          return SILC_MPI_TYPE__COLLECTIVE;
      default:
          break;
  }
  return SILC_MPI_TYPE__NONE;
}
