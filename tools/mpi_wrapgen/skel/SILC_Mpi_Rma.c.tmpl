/****************************************************************************
**  SCALASCA    http://www.scalasca.org/                                   **
**  KOJAK       http://www.fz-juelich.de/jsc/kojak/                        **
*****************************************************************************
**  Copyright (c) 1998-2009                                                **
**  Forschungszentrum Juelich, Juelich Supercomputing Centre               **
**                                                                         **
**  Copyright (c) 2003-2008                                                **
**  University of Tennessee, Innovative Computing Laboratory               **
**                                                                         **
**  See the file COPYRIGHT in the package base directory for details       **
****************************************************************************/

#include "SILC_Mpi_Reg.h"

#include <mpi.h>

/**
 * @file  SILC_Mpi_Rma.c
 *
 * @brief C interface wrappers for one-sided communication
 */

/** internal id counter for rma operations */
static int silc_rma_id = 0;

/** current rma id to use in event generation */
#define SILC_CURR_RMA_ID   silc_rma_id
/** increment and get rma id to use in event generation */
#define SILC_NEXT_RMA_ID ++silc_rma_id

/**
 * @name C wrappers for access functions
 * @{
 */
#pragma wrapgen single MPI_Accumulate skel/SILC_Mpi_RmaPut.w

/**
 * Measurement wrapper for MPI_Get
 * @note Manually adapted wrapper
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup rma
 */
int MPI_Get(void*        origin_addr,
            int          origin_count,
            MPI_Datatype origin_datatype,
            int          target_rank,
            MPI_Aint     target_disp,
            int          target_count,
            MPI_Datatype target_datatype,
            MPI_Win      win) 
{
  int return_val;

  if (SILC_MPI_IS_EVENT_GEN_ON_FOR(SILC_MPI_ENABLED_RMA))
  {
/* One-sided communication not handled in first version
    int32_t              sendsz;
    SILC_Mpi_Rank        dest_proc_rank;
    SILC_MPIWindowHandle win_handle;
*/

    SILC_MPI_EVENT_GEN_OFF();

    SILC_EnterRegion(silc_mpi_regid[SILC__MPI_GET]);

/* One-sided communication not handled in first version
    dest_proc_rank = silc_mpi_win_rank_to_pe( target_rank, win );
    win_handle = silc_mpi_win_id( win );
    
    /* in MPI_GET the target buffer is remote 
    PMPI_Type_size(target_datatype, &sendsz);
    esd_mpi_get_1ts_remote(dest_proc_rank, win_handle, SILC_NEXT_RMA_ID, target_count * sendsz);
*/    
    return_val = PMPI_Get( origin_addr, origin_count, 
                  origin_datatype, target_rank, target_disp,
                  target_count, target_datatype, win );

    /* in MPI_GET the origin buffer is local */
/* One-sided communication not handled in first version
    esd_mpi_get_1te( dest_proc_rank, win_handle, SILC_CURR_RMA_ID);
*/
    SILC_ExitRegion(silc_mpi_regid[SILC__MPI_GET]);

    SILC_MPI_EVENT_GEN_ON();
  }
  else
  {
    return_val = PMPI_Get(origin_addr, origin_count, 
                  origin_datatype, target_rank, target_disp,
                  target_count, target_datatype, win);
  }

  return return_val;
}

#pragma wrapgen single MPI_Put skel/SILC_Mpi_RmaPut.w

/**
 * @}
 * @name C wrappers for window management functions
 * @{
 */

/**
 * Measurement wrapper for MPI_Win_create
 * @note Manually adapted wrapper
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup rma
 */
int MPI_Win_create(void*    base,
                   MPI_Aint size,
                   int      disp_unit,
                   MPI_Info info, 
                   MPI_Comm comm,
                   MPI_Win* win) 
{
  const int event_gen_active = SILC_MPI_IS_EVENT_GEN_ON_FOR(SILC_MPI_ENABLED_RMA); 
  int       return_val;

  if (event_gen_active)
  {
    SILC_MPI_EVENT_GEN_OFF();

    SILC_EnterRegion(silc_mpi_regid[SILC__MPI_WIN_CREATE]);
  }
      
  return_val = PMPI_Win_create(base, size, disp_unit,
                info, comm, win );

/* One-sided communication not handled in first version
  if (*win != MPI_WIN_NULL)
  {
    silc_mpi_win_rank_create( *win, comm );
  }
*/

  if (event_gen_active)
  {
/* One-sided communication not handled in first version
    esd_mpi_wincollexit(silc_mpi_regid[SILC__MPI_WIN_CREATE], silc_mpi_win_rank_id(*win));
*/    
    SILC_MPI_EVENT_GEN_ON();
  }

  return return_val;
}

/**
 * Measurement wrapper for MPI_Win_free
 * @note Manually adapted wrapper
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup rma
 */
int MPI_Win_free(MPI_Win* win) 
{
  const int event_gen_active = SILC_MPI_IS_EVENT_GEN_ON_FOR(SILC_MPI_ENABLED_RMA); 
  int                 return_val;
/* One-sided communication not handled in first version
  SILC_MPIWindowHanle win_handle;
*/

  if (event_gen_active)
  {
    SILC_MPI_EVENT_GEN_OFF();

    SILC_EnterRegion(silc_mpi_regid[SILC__MPI_WIN_FREE]);
/* One-sided communication not handled in first version
    win_handle = silc_mpi_win_rank_id(*win);
*/
  }
      
/* One-sided communication not handled in first version
  silc_mpi_win_rank_free(*win);
*/

  return_val = PMPI_Win_free( win );

  if (event_gen_active)
  {
/* One-sided communication not handled in first version
    esd_mpi_wincollexit(silc_mpi_regid[SILC__MPI_WIN_FREE], win_handle);
*/
    
    SILC_MPI_EVENT_GEN_ON();
  }

  return return_val;
}

/**
 * @}
 * @name C wrappers for synchonization functions
 * @{
 */

/**
 * Measurement wrapper for MPI_Win_complete
 * @note Manually adapted wrapper
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup rma
 */
int MPI_Win_complete(MPI_Win win) 
{ 
  int return_val;

  if (SILC_MPI_IS_EVENT_GEN_ON_FOR(SILC_MPI_ENABLED_RMA))
  {
    SILC_MPI_EVENT_GEN_OFF();

    SILC_EnterRegion(silc_mpi_regid[SILC__MPI_WIN_COMPLETE]);

    return_val = PMPI_Win_complete(win);

/* One-sided communication not handled in first version
    esd_mpi_winexit(silc_mpi_regid[SILC__MPI_WIN_COMPLETE],
                    silc_mpi_win_rank_id(win), silc_mpi_winacc_get_gid(win, 1), 1);
    silc_mpi_winacc_end(win, 1);
*/
    SILC_MPI_EVENT_GEN_ON();
  }
  else
  {
    return_val = PMPI_Win_complete(win);
  }

  return return_val;
}

/**
 * Measurement wrapper for MPI_Win_fence
 * @note Manually adapted wrapper
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup rma
 */
int MPI_Win_fence(int     assert,
                  MPI_Win win) 
{
  int return_val;

  if (SILC_MPI_IS_EVENT_GEN_ON_FOR(SILC_MPI_ENABLED_RMA))
  {
    SILC_MPI_EVENT_GEN_OFF();

    SILC_EnterRegion(silc_mpi_regid[SILC__MPI_WIN_FENCE]);

    return_val = PMPI_Win_fence(assert, win);

/* One-sided communication not handled in first version
    esd_mpi_wincollexit(silc_mpi_regid[SILC__MPI_WIN_FENCE], silc_mpi_win_rank_id(win));
*/    
    SILC_MPI_EVENT_GEN_ON();
  }
  else
  {
    return_val = PMPI_Win_fence(assert, win);
  }

  return return_val;
}

/**
 * Measurement wrapper for MPI_Win_lock
 * @note Manually adapted wrapper
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup rma
 */
int MPI_Win_lock(int     lock_type,
                 int     rank,
                 int     assert,
                 MPI_Win win) 
{
  int return_val;

  if (SILC_MPI_IS_EVENT_GEN_ON_FOR(SILC_MPI_ENABLED_RMA))
  {
    SILC_MPI_EVENT_GEN_OFF();

    SILC_EnterRegion(silc_mpi_regid[SILC__MPI_WIN_LOCK]);

/* One-sided communication not handled in first version
    esd_mpi_win_lock( rank, silc_mpi_win_rank_id(win), lock_type==MPI_LOCK_EXCLUSIVE);
*/
    return_val = PMPI_Win_lock( lock_type, rank, 
                      assert, win );

    SILC_ExitRegion(silc_mpi_regid[SILC__MPI_WIN_LOCK]);

    SILC_MPI_EVENT_GEN_ON();
  }
  else
  {
    return_val = PMPI_Win_lock( lock_type, rank, 
                      assert, win );
  }
  return return_val;
}

/**
 * Measurement wrapper for MPI_Win_post
 * @note Manually adapted wrapper
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup rma
 */
int MPI_Win_post(MPI_Group group,
                 int       assert,
                 MPI_Win   win) 
{
  int return_val;

  if (SILC_MPI_IS_EVENT_GEN_ON_FOR(SILC_MPI_ENABLED_RMA))
  {
    SILC_MPI_EVENT_GEN_OFF();

    SILC_EnterRegion(silc_mpi_regid[SILC__MPI_WIN_POST]);

/* One-sided communication not handled in first version
    silc_mpi_winacc_start(win, group, 0);
*/
    return_val = PMPI_Win_post(group, assert, win);

/* One-sided communication not handled in first version
    esd_mpi_winexit(silc_mpi_regid[SILC__MPI_WIN_POST],
                    silc_mpi_win_rank_id(win), silc_mpi_winacc_get_gid(win, 0), 0);
*/
    SILC_MPI_EVENT_GEN_ON();
  }
  else
  {
    return_val = PMPI_Win_post(group, assert, win);
  }

  return return_val;
}

/**
 * Measurement wrapper for MPI_Win_start
 * @note Manually adapted wrapper
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup rma
 */
int MPI_Win_start(MPI_Group group,
                  int       assert,
                  MPI_Win   win) 
{
  int return_val;

  if (SILC_MPI_IS_EVENT_GEN_ON_FOR(SILC_MPI_ENABLED_RMA))
  {
    SILC_MPI_EVENT_GEN_OFF();

    SILC_EnterRegion(silc_mpi_regid[SILC__MPI_WIN_START]);

/* One-sided communication not handled in first version
    silc_mpi_winacc_start(win, group, 1);
*/
    return_val = PMPI_Win_start(group, assert, win);

/* One-sided communication not handled in first version
    esd_mpi_winexit(silc_mpi_regid[SILC__MPI_WIN_START],
                    silc_mpi_win_rank_id(win), silc_mpi_winacc_get_gid(win, 1), 0);
*/    
    SILC_MPI_EVENT_GEN_ON();
  }
  else
  {
    return_val = PMPI_Win_start(group, assert, win);
  }

  return return_val;
}

/**
 * Measurement wrapper for MPI_Win_test
 * @note Manually adapted wrapper
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup rma
 */
int MPI_Win_test(MPI_Win win,
                 int*    flag) 
{
  int return_val;

  if (SILC_MPI_IS_EVENT_GEN_ON_FOR(SILC_MPI_ENABLED_RMA))
  {
    SILC_MPI_EVENT_GEN_OFF();

    SILC_EnterRegion(silc_mpi_regid[SILC__MPI_WIN_TEST]);

    return_val = PMPI_Win_test(win, flag);
    
/* One-sided communication not handled in first version
    if (*flag != 0) 
    {
      esd_mpi_winexit(silc_mpi_regid[SILC__MPI_WIN_TEST],
                      silc_mpi_win_rank_id(win), silc_mpi_winacc_get_gid(win, 0), 1);
      silc_mpi_winacc_end(win, 0);
    }
    else
    {
      esd_mpi_winexit(silc_mpi_regid[SILC__MPI_WIN_TEST],
                      silc_mpi_win_rank_id(win), silc_mpi_winacc_get_gid(win, 0), 0);
    }
*/
    SILC_MPI_EVENT_GEN_ON();
  }
  else
  {
    return_val = PMPI_Win_test(win, flag);
  }

  return return_val;
}

/**
 * Measurement wrapper for MPI_Win_unlock
 * @note Manually adapted wrapper
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup rma
 */
int MPI_Win_unlock(int     rank,
                   MPI_Win win) 
{
  int return_val;

  if (SILC_MPI_IS_EVENT_GEN_ON_FOR(SILC_MPI_ENABLED_RMA))
  {
    SILC_MPI_EVENT_GEN_OFF();

    SILC_EnterRegion(silc_mpi_regid[SILC__MPI_WIN_UNLOCK]);

    return_val = PMPI_Win_unlock(rank, win);
/* One-sided communication not handled in first version
    esd_mpi_win_unlock(rank, silc_mpi_win_rank_id(win));
*/
    
    SILC_ExitRegion(silc_mpi_regid[SILC__MPI_WIN_UNLOCK]);

    SILC_MPI_EVENT_GEN_ON();
  }
  else
  {
    return_val = PMPI_Win_unlock(rank, win);
  }

  return return_val;
}


/**
 * Measurement wrapper for MPI_Win_wait
 * @note Manually adapted wrapper
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup rma
 */
int MPI_Win_wait(MPI_Win win) 
{
  int return_val;

  if (SILC_MPI_IS_EVENT_GEN_ON_FOR(SILC_MPI_ENABLED_RMA))
  {
    SILC_MPI_EVENT_GEN_OFF();

    SILC_EnterRegion(silc_mpi_regid[SILC__MPI_WIN_WAIT]);

    return_val = PMPI_Win_wait(win);

/* One-sided communication not handled in first version
    esd_mpi_winexit(silc_mpi_regid[SILC__MPI_WIN_WAIT],
                    silc_mpi_win_rank_id(win), silc_mpi_winacc_get_gid(win, 0), 1);
    silc_mpi_winacc_end(win, 0);
*/

    SILC_MPI_EVENT_GEN_ON();
  }
  else
  {
    return_val = PMPI_Win_wait(win);
  }

  return return_val;
}

/**
 * @}
 * @name C wrappers for error handling functions
 * @{
 */
#pragma wrapgen multiple restrict(grma_err)  skel/SILC_Mpi_Std.w

/**
 * @}
 * @name C wrappers for external interface functions
 * @{
 */
#pragma wrapgen multiple restrict(grma_ext)  skel/SILC_Mpi_Std.w

/**
 * @}
 * @name C wrappers for handle conversion functions
 * @{
 */
#pragma wrapgen multiple restrict(grma_misc+!n_c2f+!n_f2c) skel/SILC_Mpi_Std.w

/**
 * @}
 */
