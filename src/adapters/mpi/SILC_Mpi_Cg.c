/*
 * This file is part of the SILC project (http://www.silc.de)
 *
 * Copyright (c) 2009-2011,
 *    RWTH Aachen, Germany
 *    Gesellschaft fuer numerische Simulation mbH Braunschweig, Germany
 *    Technische Universitaet Dresden, Germany
 *    University of Oregon, Eugene USA
 *    Forschungszentrum Juelich GmbH, Germany
 *    Technische Universitaet Muenchen, Germany
 *
 * See the COPYING file in the package base directory for details.
 *
 */


/**
 * @file       SILC_Mpi_Cg.c
 * @maintainer Daniel Lorenz <d.lorenz@fz-juelich.de>
 * @status     alpha
 * @ingroup    MPI_Wrapper
 *
 * @brief C interface wrappers for communicator and group functions
 */

#include <config.h>
#include "SILC_Mpi.h"

/**
 * @name C wrappers for communicator constructors
 * @{
 */

#if HAVE( DECL_PMPI_COMM_CREATE )
/**
 * Measurement wrapper for MPI_Comm_create
 * @note Auto-generated by wrapgen from template: SILC_Mpi_CommMgnt.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup cg
 * It triggers an enter and an exit event. Additionally, between enter event and exit
 * event, @ref SILC_DefineMPICommunicator is called.
 */
int
MPI_Comm_create( MPI_Comm  comm,
                 MPI_Group group,
                 MPI_Comm* newcomm )
{
    const int event_gen_active = SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_CG );
    int       return_val;

    if ( event_gen_active )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_COMM_CREATE ] );
    }

    return_val = PMPI_Comm_create( comm, group, newcomm );
    if ( *newcomm != MPI_COMM_NULL )
    {
        silc_mpi_comm_create( *newcomm );
    }

    if ( event_gen_active )
    {
        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_COMM_CREATE ] );
        SILC_MPI_EVENT_GEN_ON();
    }

    return return_val;
}
#endif
#if HAVE( DECL_PMPI_COMM_DUP )
/**
 * Measurement wrapper for MPI_Comm_dup
 * @note Auto-generated by wrapgen from template: SILC_Mpi_CommMgnt.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup cg
 * It triggers an enter and an exit event. Additionally, between enter event and exit
 * event, @ref SILC_DefineMPICommunicator is called.
 */
int
MPI_Comm_dup( MPI_Comm  comm,
              MPI_Comm* newcomm )
{
    const int event_gen_active = SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_CG );
    int       return_val;

    if ( event_gen_active )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_COMM_DUP ] );
    }

    return_val = PMPI_Comm_dup( comm, newcomm );
    if ( *newcomm != MPI_COMM_NULL )
    {
        silc_mpi_comm_create( *newcomm );
    }

    if ( event_gen_active )
    {
        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_COMM_DUP ] );
        SILC_MPI_EVENT_GEN_ON();
    }

    return return_val;
}
#endif
#if HAVE( DECL_PMPI_COMM_SPLIT )
/**
 * Measurement wrapper for MPI_Comm_split
 * @note Auto-generated by wrapgen from template: SILC_Mpi_CommMgnt.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup cg
 * It triggers an enter and an exit event. Additionally, between enter event and exit
 * event, @ref SILC_DefineMPICommunicator is called.
 */
int
MPI_Comm_split( MPI_Comm  comm,
                int       color,
                int       key,
                MPI_Comm* newcomm )
{
    const int event_gen_active = SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_CG );
    int       return_val;

    if ( event_gen_active )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_COMM_SPLIT ] );
    }

    return_val = PMPI_Comm_split( comm, color, key, newcomm );
    if ( *newcomm != MPI_COMM_NULL )
    {
        silc_mpi_comm_create( *newcomm );
    }

    if ( event_gen_active )
    {
        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_COMM_SPLIT ] );
        SILC_MPI_EVENT_GEN_ON();
    }

    return return_val;
}
#endif
#if HAVE( DECL_PMPI_INTERCOMM_CREATE )
/**
 * Measurement wrapper for MPI_Intercomm_create
 * @note Auto-generated by wrapgen from template: SILC_Mpi_CommMgnt.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup cg
 * It triggers an enter and an exit event. Additionally, between enter event and exit
 * event, @ref SILC_DefineMPICommunicator is called.
 */
int
MPI_Intercomm_create( MPI_Comm  local_comm,
                      int       local_leader,
                      MPI_Comm  peer_comm,
                      int       remote_leader,
                      int       tag,
                      MPI_Comm* newcomm )
{
    const int event_gen_active = SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_CG );
    int       return_val;

    if ( event_gen_active )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_INTERCOMM_CREATE ] );
    }

    return_val = PMPI_Intercomm_create( local_comm, local_leader, peer_comm, remote_leader, tag, newcomm );
    if ( *newcomm != MPI_COMM_NULL )
    {
        silc_mpi_comm_create( *newcomm );
    }

    if ( event_gen_active )
    {
        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_INTERCOMM_CREATE ] );
        SILC_MPI_EVENT_GEN_ON();
    }

    return return_val;
}
#endif
#if HAVE( DECL_PMPI_INTERCOMM_MERGE )
/**
 * Measurement wrapper for MPI_Intercomm_merge
 * @note Auto-generated by wrapgen from template: SILC_Mpi_CommMgnt.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup cg
 * It triggers an enter and an exit event. Additionally, between enter event and exit
 * event, @ref SILC_DefineMPICommunicator is called.
 */
int
MPI_Intercomm_merge( MPI_Comm  intercomm,
                     int       high,
                     MPI_Comm* newcomm )
{
    const int event_gen_active = SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_CG );
    int       return_val;

    if ( event_gen_active )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_INTERCOMM_MERGE ] );
    }

    return_val = PMPI_Intercomm_merge( intercomm, high, newcomm );
    if ( *newcomm != MPI_COMM_NULL )
    {
        silc_mpi_comm_create( *newcomm );
    }

    if ( event_gen_active )
    {
        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_INTERCOMM_MERGE ] );
        SILC_MPI_EVENT_GEN_ON();
    }

    return return_val;
}
#endif


/**
 * @}
 * @name C wrappers for communicator destructors
 * @{
 */

#if HAVE( DECL_PMPI_COMM_FREE )
/**
 * Measurement wrapper for MPI_Comm_free
 * @note Manually adapted wrapper
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup cg
 */
int
MPI_Comm_free( MPI_Comm* comm )
{
    const int event_gen_active = SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_CG );
    int       return_val;

    if ( event_gen_active )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_COMM_FREE ] );
    }

    silc_mpi_comm_free( *comm );
    return_val = PMPI_Comm_free( comm );

    if ( event_gen_active )
    {
        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_COMM_FREE ] );
        SILC_MPI_EVENT_GEN_ON();
    }

    return return_val;
}
#endif


/**
 * @}
 * @name C wrappers for group constructors
 * @{
 */

#if HAVE( DECL_PMPI_GROUP_DIFFERENCE ) && !defined( SILC_MPI_NO_CG ) && !defined( MPI_Group_difference )
/**
 * Measurement wrapper for MPI_Group_difference
 * @note Auto-generated by wrapgen from template: SILC_Mpi_GroupMgnt.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup cg
 * Triggers an enter event and an exit event. Furthermore, a communicator definition
 * event is called between enter and exit.
 */
int
MPI_Group_difference( MPI_Group  group1,
                      MPI_Group  group2,
                      MPI_Group* newgroup )
{
    const int event_gen_active = SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_CG );
    int       return_val;

    if ( event_gen_active )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_GROUP_DIFFERENCE ] );
    }

    return_val = PMPI_Group_difference( group1, group2, newgroup );
    if ( *newgroup != MPI_GROUP_NULL )
    {
        silc_mpi_group_create( *newgroup );
    }

    if ( event_gen_active )
    {
        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_GROUP_DIFFERENCE ] );
        SILC_MPI_EVENT_GEN_ON();
    }

    return return_val;
}
#endif
#if HAVE( DECL_PMPI_GROUP_EXCL ) && !defined( SILC_MPI_NO_CG ) && !defined( MPI_Group_excl )
/**
 * Measurement wrapper for MPI_Group_excl
 * @note Auto-generated by wrapgen from template: SILC_Mpi_GroupMgnt.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup cg
 * Triggers an enter event and an exit event. Furthermore, a communicator definition
 * event is called between enter and exit.
 */
int
MPI_Group_excl( MPI_Group  group,
                int        n,
                int*       ranks,
                MPI_Group* newgroup )
{
    const int event_gen_active = SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_CG );
    int       return_val;

    if ( event_gen_active )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_GROUP_EXCL ] );
    }

    return_val = PMPI_Group_excl( group, n, ranks, newgroup );
    if ( *newgroup != MPI_GROUP_NULL )
    {
        silc_mpi_group_create( *newgroup );
    }

    if ( event_gen_active )
    {
        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_GROUP_EXCL ] );
        SILC_MPI_EVENT_GEN_ON();
    }

    return return_val;
}
#endif
#if HAVE( DECL_PMPI_GROUP_INCL ) && !defined( SILC_MPI_NO_CG ) && !defined( MPI_Group_incl )
/**
 * Measurement wrapper for MPI_Group_incl
 * @note Auto-generated by wrapgen from template: SILC_Mpi_GroupMgnt.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup cg
 * Triggers an enter event and an exit event. Furthermore, a communicator definition
 * event is called between enter and exit.
 */
int
MPI_Group_incl( MPI_Group  group,
                int        n,
                int*       ranks,
                MPI_Group* newgroup )
{
    const int event_gen_active = SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_CG );
    int       return_val;

    if ( event_gen_active )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_GROUP_INCL ] );
    }

    return_val = PMPI_Group_incl( group, n, ranks, newgroup );
    if ( *newgroup != MPI_GROUP_NULL )
    {
        silc_mpi_group_create( *newgroup );
    }

    if ( event_gen_active )
    {
        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_GROUP_INCL ] );
        SILC_MPI_EVENT_GEN_ON();
    }

    return return_val;
}
#endif
#if HAVE( DECL_PMPI_GROUP_INTERSECTION ) && !defined( SILC_MPI_NO_CG ) && !defined( MPI_Group_intersection )
/**
 * Measurement wrapper for MPI_Group_intersection
 * @note Auto-generated by wrapgen from template: SILC_Mpi_GroupMgnt.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup cg
 * Triggers an enter event and an exit event. Furthermore, a communicator definition
 * event is called between enter and exit.
 */
int
MPI_Group_intersection( MPI_Group  group1,
                        MPI_Group  group2,
                        MPI_Group* newgroup )
{
    const int event_gen_active = SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_CG );
    int       return_val;

    if ( event_gen_active )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_GROUP_INTERSECTION ] );
    }

    return_val = PMPI_Group_intersection( group1, group2, newgroup );
    if ( *newgroup != MPI_GROUP_NULL )
    {
        silc_mpi_group_create( *newgroup );
    }

    if ( event_gen_active )
    {
        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_GROUP_INTERSECTION ] );
        SILC_MPI_EVENT_GEN_ON();
    }

    return return_val;
}
#endif
#if HAVE( DECL_PMPI_GROUP_RANGE_EXCL ) && !defined( SILC_MPI_NO_CG ) && !defined( MPI_Group_range_excl )
/**
 * Measurement wrapper for MPI_Group_range_excl
 * @note Auto-generated by wrapgen from template: SILC_Mpi_GroupMgnt.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup cg
 * Triggers an enter event and an exit event. Furthermore, a communicator definition
 * event is called between enter and exit.
 */
int
MPI_Group_range_excl( MPI_Group  group,
                      int        n,
                      int        ranges[][ 3 ],
                      MPI_Group* newgroup )
{
    const int event_gen_active = SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_CG );
    int       return_val;

    if ( event_gen_active )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_GROUP_RANGE_EXCL ] );
    }

    return_val = PMPI_Group_range_excl( group, n, ranges, newgroup );
    if ( *newgroup != MPI_GROUP_NULL )
    {
        silc_mpi_group_create( *newgroup );
    }

    if ( event_gen_active )
    {
        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_GROUP_RANGE_EXCL ] );
        SILC_MPI_EVENT_GEN_ON();
    }

    return return_val;
}
#endif
#if HAVE( DECL_PMPI_GROUP_RANGE_INCL ) && !defined( SILC_MPI_NO_CG ) && !defined( MPI_Group_range_incl )
/**
 * Measurement wrapper for MPI_Group_range_incl
 * @note Auto-generated by wrapgen from template: SILC_Mpi_GroupMgnt.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup cg
 * Triggers an enter event and an exit event. Furthermore, a communicator definition
 * event is called between enter and exit.
 */
int
MPI_Group_range_incl( MPI_Group  group,
                      int        n,
                      int        ranges[][ 3 ],
                      MPI_Group* newgroup )
{
    const int event_gen_active = SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_CG );
    int       return_val;

    if ( event_gen_active )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_GROUP_RANGE_INCL ] );
    }

    return_val = PMPI_Group_range_incl( group, n, ranges, newgroup );
    if ( *newgroup != MPI_GROUP_NULL )
    {
        silc_mpi_group_create( *newgroup );
    }

    if ( event_gen_active )
    {
        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_GROUP_RANGE_INCL ] );
        SILC_MPI_EVENT_GEN_ON();
    }

    return return_val;
}
#endif
#if HAVE( DECL_PMPI_GROUP_UNION ) && !defined( SILC_MPI_NO_CG ) && !defined( MPI_Group_union )
/**
 * Measurement wrapper for MPI_Group_union
 * @note Auto-generated by wrapgen from template: SILC_Mpi_GroupMgnt.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup cg
 * Triggers an enter event and an exit event. Furthermore, a communicator definition
 * event is called between enter and exit.
 */
int
MPI_Group_union( MPI_Group  group1,
                 MPI_Group  group2,
                 MPI_Group* newgroup )
{
    const int event_gen_active = SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_CG );
    int       return_val;

    if ( event_gen_active )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_GROUP_UNION ] );
    }

    return_val = PMPI_Group_union( group1, group2, newgroup );
    if ( *newgroup != MPI_GROUP_NULL )
    {
        silc_mpi_group_create( *newgroup );
    }

    if ( event_gen_active )
    {
        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_GROUP_UNION ] );
        SILC_MPI_EVENT_GEN_ON();
    }

    return return_val;
}
#endif
#if HAVE( DECL_PMPI_COMM_GROUP )
/**
 * Measurement wrapper for MPI_Comm_group
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Group.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup cg
 * Triggers an enter event and an exit event. Furthermore, a communicator definition
 * event is called between enter and exit.
 */
int
MPI_Comm_group( MPI_Comm   comm,
                MPI_Group* group )
{
    const int event_gen_active = SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_CG );
    int       return_val;

    if ( event_gen_active )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_COMM_GROUP ] );
    }

    return_val = PMPI_Comm_group( comm, group );
    if ( *group != MPI_GROUP_NULL )
    {
        silc_mpi_group_create( *group );
    }

    if ( event_gen_active )
    {
        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_COMM_GROUP ] );
        SILC_MPI_EVENT_GEN_ON();
    }

    return return_val;
}
#endif
#if HAVE( DECL_PMPI_COMM_REMOTE_GROUP )
/**
 * Measurement wrapper for MPI_Comm_remote_group
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Group.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup cg
 * Triggers an enter event and an exit event. Furthermore, a communicator definition
 * event is called between enter and exit.
 */
int
MPI_Comm_remote_group( MPI_Comm   comm,
                       MPI_Group* group )
{
    const int event_gen_active = SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_CG );
    int       return_val;

    if ( event_gen_active )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_COMM_REMOTE_GROUP ] );
    }

    return_val = PMPI_Comm_remote_group( comm, group );
    if ( *group != MPI_GROUP_NULL )
    {
        silc_mpi_group_create( *group );
    }

    if ( event_gen_active )
    {
        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_COMM_REMOTE_GROUP ] );
        SILC_MPI_EVENT_GEN_ON();
    }

    return return_val;
}
#endif

/**
 * @}
 * @name C wrappers for group destructors
 * @{
 */

#if HAVE( DECL_PMPI_GROUP_FREE )
/**
 * Measurement wrapper for MPI_Group_free
 * @note Manually adapted wrapper
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup cg
 */
int
MPI_Group_free( MPI_Group* group )
{
    const int event_gen_active = SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_CG );
    int       return_val;

    if ( event_gen_active )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_GROUP_FREE ] );
    }

    silc_mpi_group_free( *group );
    return_val = PMPI_Group_free( group );

    if ( event_gen_active )
    {
        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_GROUP_FREE ] );
        SILC_MPI_EVENT_GEN_ON();
    }

    return return_val;
}
#endif

/**
 * @}
 * @name C wrappers for miscelaneous functions
 * @{
 */

#if HAVE( DECL_PMPI_COMM_COMPARE ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_CG ) && !defined( MPI_Comm_compare )
/**
 * Measurement wrapper for MPI_Comm_compare
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup cg
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Comm_compare( MPI_Comm comm1,
                  MPI_Comm comm2,
                  int*     result )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_CG ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_COMM_COMPARE ] );

        return_val = PMPI_Comm_compare( comm1, comm2, result );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_COMM_COMPARE ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Comm_compare( comm1, comm2, result );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_COMM_RANK ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_MINI ) && !defined( SILC_MPI_NO_CG ) && !defined( MPI_Comm_rank )
/**
 * Measurement wrapper for MPI_Comm_rank
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup cg
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Comm_rank( MPI_Comm comm,
               int*     rank )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_CG ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_COMM_RANK ] );

        return_val = PMPI_Comm_rank( comm, rank );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_COMM_RANK ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Comm_rank( comm, rank );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_COMM_SIZE ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_MINI ) && !defined( SILC_MPI_NO_CG ) && !defined( MPI_Comm_size )
/**
 * Measurement wrapper for MPI_Comm_size
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup cg
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Comm_size( MPI_Comm comm,
               int*     size )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_CG ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_COMM_SIZE ] );

        return_val = PMPI_Comm_size( comm, size );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_COMM_SIZE ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Comm_size( comm, size );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_COMM_TEST_INTER ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_CG ) && !defined( MPI_Comm_test_inter )
/**
 * Measurement wrapper for MPI_Comm_test_inter
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup cg
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Comm_test_inter( MPI_Comm comm,
                     int*     flag )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_CG ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_COMM_TEST_INTER ] );

        return_val = PMPI_Comm_test_inter( comm, flag );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_COMM_TEST_INTER ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Comm_test_inter( comm, flag );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_GROUP_COMPARE ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_CG ) && !defined( MPI_Group_compare )
/**
 * Measurement wrapper for MPI_Group_compare
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup cg
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Group_compare( MPI_Group group1,
                   MPI_Group group2,
                   int*      result )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_CG ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_GROUP_COMPARE ] );

        return_val = PMPI_Group_compare( group1, group2, result );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_GROUP_COMPARE ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Group_compare( group1, group2, result );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_GROUP_RANK ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_CG ) && !defined( MPI_Group_rank )
/**
 * Measurement wrapper for MPI_Group_rank
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup cg
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Group_rank( MPI_Group group,
                int*      rank )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_CG ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_GROUP_RANK ] );

        return_val = PMPI_Group_rank( group, rank );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_GROUP_RANK ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Group_rank( group, rank );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_GROUP_SIZE ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_CG ) && !defined( MPI_Group_size )
/**
 * Measurement wrapper for MPI_Group_size
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup cg
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Group_size( MPI_Group group,
                int*      size )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_CG ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_GROUP_SIZE ] );

        return_val = PMPI_Group_size( group, size );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_GROUP_SIZE ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Group_size( group, size );
    }

    return return_val;
}
#endif


/**
 * @}
 * @name C wrappers for error handling functions
 * @{
 */

#if HAVE( DECL_PMPI_COMM_CALL_ERRHANDLER ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_CG ) && !defined( SILC_MPI_NO_ERR ) && !defined( MPI_Comm_call_errhandler )
/**
 * Measurement wrapper for MPI_Comm_call_errhandler
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup cg_err
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Comm_call_errhandler( MPI_Comm comm,
                          int      errorcode )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_CG_ERR ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_COMM_CALL_ERRHANDLER ] );

        return_val = PMPI_Comm_call_errhandler( comm, errorcode );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_COMM_CALL_ERRHANDLER ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Comm_call_errhandler( comm, errorcode );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_COMM_CREATE_ERRHANDLER ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_CG ) && !defined( SILC_MPI_NO_ERR ) && !defined( MPI_Comm_create_errhandler )
/**
 * Measurement wrapper for MPI_Comm_create_errhandler
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup cg_err
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Comm_create_errhandler( MPI_Comm_errhandler_fn* function,
                            MPI_Errhandler*         errhandler )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_CG_ERR ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_COMM_CREATE_ERRHANDLER ] );

        return_val = PMPI_Comm_create_errhandler( function, errhandler );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_COMM_CREATE_ERRHANDLER ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Comm_create_errhandler( function, errhandler );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_COMM_GET_ERRHANDLER ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_CG ) && !defined( SILC_MPI_NO_ERR ) && !defined( MPI_Comm_get_errhandler )
/**
 * Measurement wrapper for MPI_Comm_get_errhandler
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup cg_err
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Comm_get_errhandler( MPI_Comm        comm,
                         MPI_Errhandler* errhandler )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_CG_ERR ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_COMM_GET_ERRHANDLER ] );

        return_val = PMPI_Comm_get_errhandler( comm, errhandler );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_COMM_GET_ERRHANDLER ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Comm_get_errhandler( comm, errhandler );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_COMM_SET_ERRHANDLER ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_CG ) && !defined( SILC_MPI_NO_ERR ) && !defined( MPI_Comm_set_errhandler )
/**
 * Measurement wrapper for MPI_Comm_set_errhandler
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup cg_err
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Comm_set_errhandler( MPI_Comm       comm,
                         MPI_Errhandler errhandler )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_CG_ERR ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_COMM_SET_ERRHANDLER ] );

        return_val = PMPI_Comm_set_errhandler( comm, errhandler );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_COMM_SET_ERRHANDLER ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Comm_set_errhandler( comm, errhandler );
    }

    return return_val;
}
#endif


/**
 * @}
 * @name C wrappers for external interface functions
 * @{
 */

#if HAVE( DECL_PMPI_ATTR_DELETE ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_CG ) && !defined( SILC_MPI_NO_EXT ) && !defined( MPI_Attr_delete )
/**
 * Measurement wrapper for MPI_Attr_delete
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup cg_ext
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Attr_delete( MPI_Comm comm,
                 int      keyval )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_CG_EXT ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_ATTR_DELETE ] );

        return_val = PMPI_Attr_delete( comm, keyval );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_ATTR_DELETE ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Attr_delete( comm, keyval );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_ATTR_GET ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_CG ) && !defined( SILC_MPI_NO_EXT ) && !defined( MPI_Attr_get )
/**
 * Measurement wrapper for MPI_Attr_get
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup cg_ext
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Attr_get( MPI_Comm comm,
              int      keyval,
              void*    attribute_val,
              int*     flag )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_CG_EXT ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_ATTR_GET ] );

        return_val = PMPI_Attr_get( comm, keyval, attribute_val, flag );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_ATTR_GET ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Attr_get( comm, keyval, attribute_val, flag );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_ATTR_PUT ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_CG ) && !defined( SILC_MPI_NO_EXT ) && !defined( MPI_Attr_put )
/**
 * Measurement wrapper for MPI_Attr_put
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup cg_ext
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Attr_put( MPI_Comm comm,
              int      keyval,
              void*    attribute_val )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_CG_EXT ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_ATTR_PUT ] );

        return_val = PMPI_Attr_put( comm, keyval, attribute_val );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_ATTR_PUT ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Attr_put( comm, keyval, attribute_val );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_COMM_CREATE_KEYVAL ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_CG ) && !defined( SILC_MPI_NO_EXT ) && !defined( MPI_Comm_create_keyval )
/**
 * Measurement wrapper for MPI_Comm_create_keyval
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup cg_ext
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Comm_create_keyval( MPI_Comm_copy_attr_function*   comm_copy_attr_fn,
                        MPI_Comm_delete_attr_function* comm_delete_attr_fn,
                        int*                           comm_keyval,
                        void*                          extra_state )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_CG_EXT ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_COMM_CREATE_KEYVAL ] );

        return_val = PMPI_Comm_create_keyval( comm_copy_attr_fn, comm_delete_attr_fn, comm_keyval, extra_state );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_COMM_CREATE_KEYVAL ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Comm_create_keyval( comm_copy_attr_fn, comm_delete_attr_fn, comm_keyval, extra_state );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_COMM_DELETE_ATTR ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_CG ) && !defined( SILC_MPI_NO_EXT ) && !defined( MPI_Comm_delete_attr )
/**
 * Measurement wrapper for MPI_Comm_delete_attr
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup cg_ext
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Comm_delete_attr( MPI_Comm comm,
                      int      comm_keyval )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_CG_EXT ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_COMM_DELETE_ATTR ] );

        return_val = PMPI_Comm_delete_attr( comm, comm_keyval );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_COMM_DELETE_ATTR ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Comm_delete_attr( comm, comm_keyval );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_COMM_FREE_KEYVAL ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_CG ) && !defined( SILC_MPI_NO_EXT ) && !defined( MPI_Comm_free_keyval )
/**
 * Measurement wrapper for MPI_Comm_free_keyval
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup cg_ext
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Comm_free_keyval( int* comm_keyval )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_CG_EXT ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_COMM_FREE_KEYVAL ] );

        return_val = PMPI_Comm_free_keyval( comm_keyval );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_COMM_FREE_KEYVAL ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Comm_free_keyval( comm_keyval );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_COMM_GET_ATTR ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_CG ) && !defined( SILC_MPI_NO_EXT ) && !defined( MPI_Comm_get_attr )
/**
 * Measurement wrapper for MPI_Comm_get_attr
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup cg_ext
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Comm_get_attr( MPI_Comm comm,
                   int      comm_keyval,
                   void*    attribute_val,
                   int*     flag )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_CG_EXT ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_COMM_GET_ATTR ] );

        return_val = PMPI_Comm_get_attr( comm, comm_keyval, attribute_val, flag );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_COMM_GET_ATTR ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Comm_get_attr( comm, comm_keyval, attribute_val, flag );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_COMM_GET_NAME ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_CG ) && !defined( SILC_MPI_NO_EXT ) && !defined( MPI_Comm_get_name )
/**
 * Measurement wrapper for MPI_Comm_get_name
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup cg_ext
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Comm_get_name( MPI_Comm comm,
                   char*    comm_name,
                   int*     resultlen )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_CG_EXT ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_COMM_GET_NAME ] );

        return_val = PMPI_Comm_get_name( comm, comm_name, resultlen );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_COMM_GET_NAME ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Comm_get_name( comm, comm_name, resultlen );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_COMM_SET_ATTR ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_CG ) && !defined( SILC_MPI_NO_EXT ) && !defined( MPI_Comm_set_attr )
/**
 * Measurement wrapper for MPI_Comm_set_attr
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup cg_ext
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Comm_set_attr( MPI_Comm comm,
                   int      comm_keyval,
                   void*    attribute_val )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_CG_EXT ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_COMM_SET_ATTR ] );

        return_val = PMPI_Comm_set_attr( comm, comm_keyval, attribute_val );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_COMM_SET_ATTR ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Comm_set_attr( comm, comm_keyval, attribute_val );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_COMM_SET_NAME ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_CG ) && !defined( SILC_MPI_NO_EXT ) && !defined( MPI_Comm_set_name )
/**
 * Measurement wrapper for MPI_Comm_set_name
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup cg_ext
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Comm_set_name( MPI_Comm comm,
                   char*    comm_name )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_CG_EXT ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_COMM_SET_NAME ] );

        return_val = PMPI_Comm_set_name( comm, comm_name );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_COMM_SET_NAME ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Comm_set_name( comm, comm_name );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_KEYVAL_CREATE ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_CG ) && !defined( SILC_MPI_NO_EXT ) && !defined( MPI_Keyval_create )
/**
 * Measurement wrapper for MPI_Keyval_create
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup cg_ext
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Keyval_create( MPI_Copy_function*   copy_fn,
                   MPI_Delete_function* delete_fn,
                   int*                 keyval,
                   void*                extra_state )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_CG_EXT ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_KEYVAL_CREATE ] );

        return_val = PMPI_Keyval_create( copy_fn, delete_fn, keyval, extra_state );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_KEYVAL_CREATE ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Keyval_create( copy_fn, delete_fn, keyval, extra_state );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_KEYVAL_FREE ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_CG ) && !defined( SILC_MPI_NO_EXT ) && !defined( MPI_Keyval_free )
/**
 * Measurement wrapper for MPI_Keyval_free
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup cg_ext
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Keyval_free( int* keyval )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_CG_EXT ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_KEYVAL_FREE ] );

        return_val = PMPI_Keyval_free( keyval );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_KEYVAL_FREE ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Keyval_free( keyval );
    }

    return return_val;
}
#endif


/**
 * @}
 * @name C wrappers for handle conversion functions
 * @{
 */


/**
 * @}
 */
