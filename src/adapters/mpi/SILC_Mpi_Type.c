/*
 * This file is part of the SILC project (http://www.silc.de)
 *
 * Copyright (c) 2009-2011,
 *    RWTH Aachen, Germany
 *    Gesellschaft fuer numerische Simulation mbH Braunschweig, Germany
 *    Technische Universitaet Dresden, Germany
 *    University of Oregon, Eugene USA
 *    Forschungszentrum Juelich GmbH, Germany
 *    Technische Universitaet Muenchen, Germany
 *
 * See the COPYING file in the package base directory for details.
 *
 */


#include "SILC_Mpi.h"
#include "config.h"

/**
 * @file       SILC_Mpi_Type.c
 * @maintainer Daniel Lorenz <d.lorenz@fz-juelich.de>
 * @status     ALPHA
 * @ingroup    MPI_Wrapper
 *
 * @brief C interface wrappers for datatype functions
 */

/**
 * @name C wrappers for general functions
 * @{
 */

#if HAVE( DECL_MPI_SIZEOF ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_TYPE )
/**
 * Measurement wrapper for MPI_Sizeof
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Sizeof( MPI_Datatype x,
            int          size )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_TYPE ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_SIZEOF ] );

        return_val = PMPI_Sizeof( x, size );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_SIZEOF ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Sizeof( x, size );
    }

    return return_val;
}
#endif


#if HAVE( DECL_MPI_PACK ) && !defined( SILC_MPI_NO_EXTRA )
/**
 * Measurement wrapper for MPI_Pack
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Pack( void*        inbuf,
          int          incount,
          MPI_Datatype datatype,
          void*        outbuf,
          int          outsize,
          int*         position,
          MPI_Comm     comm )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_TYPE ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_PACK ] );

        return_val = PMPI_Pack( inbuf, incount, datatype, outbuf, outsize, position, comm );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_PACK ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Pack( inbuf, incount, datatype, outbuf, outsize, position, comm );
    }

    return return_val;
}
#endif

#if HAVE( DECL_MPI_PACK_EXTERNAL ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_TYPE )
/**
 * Measurement wrapper for MPI_Pack_external
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Pack_external( char*        datarep,
                   void*        inbuf,
                   int          incount,
                   MPI_Datatype datatype,
                   void*        outbuf,
                   MPI_Aint     outsize,
                   MPI_Aint*    position )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_TYPE ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_PACK_EXTERNAL ] );

        return_val = PMPI_Pack_external( datarep, inbuf, incount, datatype, outbuf, outsize, position );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_PACK_EXTERNAL ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Pack_external( datarep, inbuf, incount, datatype, outbuf, outsize, position );
    }

    return return_val;
}
#endif

#if HAVE( DECL_MPI_PACK_EXTERNAL_SIZE ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_TYPE )
/**
 * Measurement wrapper for MPI_Pack_external_size
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Pack_external_size( char*        datarep,
                        int          incount,
                        MPI_Datatype datatype,
                        MPI_Aint*    size )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_TYPE ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_PACK_EXTERNAL_SIZE ] );

        return_val = PMPI_Pack_external_size( datarep, incount, datatype, size );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_PACK_EXTERNAL_SIZE ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Pack_external_size( datarep, incount, datatype, size );
    }

    return return_val;
}
#endif

#if HAVE( DECL_MPI_PACK_SIZE ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_TYPE )
/**
 * Measurement wrapper for MPI_Pack_size
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Pack_size( int          incount,
               MPI_Datatype datatype,
               MPI_Comm     comm,
               int*         size )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_TYPE ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_PACK_SIZE ] );

        return_val = PMPI_Pack_size( incount, datatype, comm, size );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_PACK_SIZE ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Pack_size( incount, datatype, comm, size );
    }

    return return_val;
}
#endif

#if HAVE( DECL_MPI_TYPE_COMMIT ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_TYPE )
/**
 * Measurement wrapper for MPI_Type_commit
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Type_commit( MPI_Datatype* datatype )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_TYPE ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_TYPE_COMMIT ] );

        return_val = PMPI_Type_commit( datatype );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_TYPE_COMMIT ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_commit( datatype );
    }

    return return_val;
}
#endif

#if HAVE( DECL_MPI_TYPE_CONTIGUOUS ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_TYPE )
/**
 * Measurement wrapper for MPI_Type_contiguous
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Type_contiguous( int           count,
                     MPI_Datatype  oldtype,
                     MPI_Datatype* newtype )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_TYPE ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_TYPE_CONTIGUOUS ] );

        return_val = PMPI_Type_contiguous( count, oldtype, newtype );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_TYPE_CONTIGUOUS ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_contiguous( count, oldtype, newtype );
    }

    return return_val;
}
#endif

#if HAVE( DECL_MPI_TYPE_CREATE_DARRAY ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_TYPE )
/**
 * Measurement wrapper for MPI_Type_create_darray
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Type_create_darray( int           size,
                        int           rank,
                        int           ndims,
                        int           array_of_gsizes[],
                        int           array_of_distribs[],
                        int           array_of_dargs[],
                        int           array_of_psizes[],
                        int           order,
                        MPI_Datatype  oldtype,
                        MPI_Datatype* newtype )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_TYPE ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_TYPE_CREATE_DARRAY ] );

        return_val = PMPI_Type_create_darray( size, rank, ndims, array_of_gsizes, array_of_distribs, array_of_dargs, array_of_psizes, order, oldtype, newtype );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_TYPE_CREATE_DARRAY ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_create_darray( size, rank, ndims, array_of_gsizes, array_of_distribs, array_of_dargs, array_of_psizes, order, oldtype, newtype );
    }

    return return_val;
}
#endif

#if HAVE( DECL_MPI_TYPE_CREATE_F90_COMPLEX ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_TYPE )
/**
 * Measurement wrapper for MPI_Type_create_f90_complex
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Type_create_f90_complex( int           p,
                             int           r,
                             MPI_Datatype* newtype )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_TYPE ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_TYPE_CREATE_F90_COMPLEX ] );

        return_val = PMPI_Type_create_f90_complex( p, r, newtype );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_TYPE_CREATE_F90_COMPLEX ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_create_f90_complex( p, r, newtype );
    }

    return return_val;
}
#endif

#if HAVE( DECL_MPI_TYPE_CREATE_F90_INTEGER ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_TYPE )
/**
 * Measurement wrapper for MPI_Type_create_f90_integer
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Type_create_f90_integer( int           r,
                             MPI_Datatype* newtype )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_TYPE ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_TYPE_CREATE_F90_INTEGER ] );

        return_val = PMPI_Type_create_f90_integer( r, newtype );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_TYPE_CREATE_F90_INTEGER ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_create_f90_integer( r, newtype );
    }

    return return_val;
}
#endif

#if HAVE( DECL_MPI_TYPE_CREATE_F90_REAL ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_TYPE )
/**
 * Measurement wrapper for MPI_Type_create_f90_real
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Type_create_f90_real( int           p,
                          int           r,
                          MPI_Datatype* newtype )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_TYPE ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_TYPE_CREATE_F90_REAL ] );

        return_val = PMPI_Type_create_f90_real( p, r, newtype );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_TYPE_CREATE_F90_REAL ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_create_f90_real( p, r, newtype );
    }

    return return_val;
}
#endif

#if HAVE( DECL_MPI_TYPE_CREATE_HINDEXED ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_TYPE )
/**
 * Measurement wrapper for MPI_Type_create_hindexed
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Type_create_hindexed( int           count,
                          int           array_of_blocklengths[],
                          MPI_Aint      array_of_displacements[],
                          MPI_Datatype  oldtype,
                          MPI_Datatype* newtype )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_TYPE ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_TYPE_CREATE_HINDEXED ] );

        return_val = PMPI_Type_create_hindexed( count, array_of_blocklengths, array_of_displacements, oldtype, newtype );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_TYPE_CREATE_HINDEXED ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_create_hindexed( count, array_of_blocklengths, array_of_displacements, oldtype, newtype );
    }

    return return_val;
}
#endif

#if HAVE( DECL_MPI_TYPE_CREATE_HVECTOR ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_TYPE )
/**
 * Measurement wrapper for MPI_Type_create_hvector
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Type_create_hvector( int           count,
                         int           blocklength,
                         MPI_Aint      stride,
                         MPI_Datatype  oldtype,
                         MPI_Datatype* newtype )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_TYPE ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_TYPE_CREATE_HVECTOR ] );

        return_val = PMPI_Type_create_hvector( count, blocklength, stride, oldtype, newtype );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_TYPE_CREATE_HVECTOR ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_create_hvector( count, blocklength, stride, oldtype, newtype );
    }

    return return_val;
}
#endif

#if HAVE( DECL_MPI_TYPE_CREATE_INDEXED_BLOCK ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_TYPE )
/**
 * Measurement wrapper for MPI_Type_create_indexed_block
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Type_create_indexed_block( int           count,
                               int           blocklength,
                               int           array_of_displacements[],
                               MPI_Datatype  oldtype,
                               MPI_Datatype* newtype )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_TYPE ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_TYPE_CREATE_INDEXED_BLOCK ] );

        return_val = PMPI_Type_create_indexed_block( count, blocklength, array_of_displacements, oldtype, newtype );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_TYPE_CREATE_INDEXED_BLOCK ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_create_indexed_block( count, blocklength, array_of_displacements, oldtype, newtype );
    }

    return return_val;
}
#endif

#if HAVE( DECL_MPI_TYPE_CREATE_RESIZED ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_TYPE )
/**
 * Measurement wrapper for MPI_Type_create_resized
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Type_create_resized( MPI_Datatype  oldtype,
                         MPI_Aint      lb,
                         MPI_Aint      extent,
                         MPI_Datatype* newtype )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_TYPE ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_TYPE_CREATE_RESIZED ] );

        return_val = PMPI_Type_create_resized( oldtype, lb, extent, newtype );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_TYPE_CREATE_RESIZED ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_create_resized( oldtype, lb, extent, newtype );
    }

    return return_val;
}
#endif

#if HAVE( DECL_MPI_TYPE_CREATE_STRUCT ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_TYPE )
/**
 * Measurement wrapper for MPI_Type_create_struct
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Type_create_struct( int           count,
                        int           array_of_blocklengths[],
                        MPI_Aint      array_of_displacements[],
                        MPI_Datatype  array_of_types[],
                        MPI_Datatype* newtype )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_TYPE ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_TYPE_CREATE_STRUCT ] );

        return_val = PMPI_Type_create_struct( count, array_of_blocklengths, array_of_displacements, array_of_types, newtype );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_TYPE_CREATE_STRUCT ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_create_struct( count, array_of_blocklengths, array_of_displacements, array_of_types, newtype );
    }

    return return_val;
}
#endif

#if HAVE( DECL_MPI_TYPE_CREATE_SUBARRAY ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_TYPE )
/**
 * Measurement wrapper for MPI_Type_create_subarray
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Type_create_subarray( int           ndims,
                          int           array_of_sizes[],
                          int           array_of_subsizes[],
                          int           array_of_starts[],
                          int           order,
                          MPI_Datatype  oldtype,
                          MPI_Datatype* newtype )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_TYPE ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_TYPE_CREATE_SUBARRAY ] );

        return_val = PMPI_Type_create_subarray( ndims, array_of_sizes, array_of_subsizes, array_of_starts, order, oldtype, newtype );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_TYPE_CREATE_SUBARRAY ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_create_subarray( ndims, array_of_sizes, array_of_subsizes, array_of_starts, order, oldtype, newtype );
    }

    return return_val;
}
#endif

#if HAVE( DECL_MPI_TYPE_DUP ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_TYPE )
/**
 * Measurement wrapper for MPI_Type_dup
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Type_dup( MPI_Datatype  type,
              MPI_Datatype* newtype )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_TYPE ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_TYPE_DUP ] );

        return_val = PMPI_Type_dup( type, newtype );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_TYPE_DUP ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_dup( type, newtype );
    }

    return return_val;
}
#endif

#if HAVE( DECL_MPI_TYPE_EXTENT ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_TYPE )
/**
 * Measurement wrapper for MPI_Type_extent
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Type_extent( MPI_Datatype datatype,
                 MPI_Aint*    extent )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_TYPE ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_TYPE_EXTENT ] );

        return_val = PMPI_Type_extent( datatype, extent );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_TYPE_EXTENT ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_extent( datatype, extent );
    }

    return return_val;
}
#endif

#if HAVE( DECL_MPI_TYPE_FREE ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_TYPE )
/**
 * Measurement wrapper for MPI_Type_free
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Type_free( MPI_Datatype* datatype )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_TYPE ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_TYPE_FREE ] );

        return_val = PMPI_Type_free( datatype );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_TYPE_FREE ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_free( datatype );
    }

    return return_val;
}
#endif

#if HAVE( DECL_MPI_TYPE_GET_CONTENTS ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_TYPE )
/**
 * Measurement wrapper for MPI_Type_get_contents
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Type_get_contents( MPI_Datatype datatype,
                       int          max_integers,
                       int          max_addresses,
                       int          max_datatypes,
                       int          array_of_integers[],
                       MPI_Aint     array_of_addresses[],
                       MPI_Datatype array_of_datatypes[] )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_TYPE ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_TYPE_GET_CONTENTS ] );

        return_val = PMPI_Type_get_contents( datatype, max_integers, max_addresses, max_datatypes, array_of_integers, array_of_addresses, array_of_datatypes );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_TYPE_GET_CONTENTS ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_get_contents( datatype, max_integers, max_addresses, max_datatypes, array_of_integers, array_of_addresses, array_of_datatypes );
    }

    return return_val;
}
#endif

#if HAVE( DECL_MPI_TYPE_GET_ENVELOPE ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_TYPE )
/**
 * Measurement wrapper for MPI_Type_get_envelope
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Type_get_envelope( MPI_Datatype datatype,
                       int*         num_integers,
                       int*         num_addresses,
                       int*         num_datatypes,
                       int*         combiner )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_TYPE ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_TYPE_GET_ENVELOPE ] );

        return_val = PMPI_Type_get_envelope( datatype, num_integers, num_addresses, num_datatypes, combiner );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_TYPE_GET_ENVELOPE ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_get_envelope( datatype, num_integers, num_addresses, num_datatypes, combiner );
    }

    return return_val;
}
#endif

#if HAVE( DECL_MPI_TYPE_GET_EXTENT ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_TYPE )
/**
 * Measurement wrapper for MPI_Type_get_extent
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Type_get_extent( MPI_Datatype datatype,
                     MPI_Aint*    lb,
                     MPI_Aint*    extent )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_TYPE ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_TYPE_GET_EXTENT ] );

        return_val = PMPI_Type_get_extent( datatype, lb, extent );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_TYPE_GET_EXTENT ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_get_extent( datatype, lb, extent );
    }

    return return_val;
}
#endif

#if HAVE( DECL_MPI_TYPE_GET_TRUE_EXTENT ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_TYPE )
/**
 * Measurement wrapper for MPI_Type_get_true_extent
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Type_get_true_extent( MPI_Datatype datatype,
                          MPI_Aint*    true_lb,
                          MPI_Aint*    true_extent )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_TYPE ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_TYPE_GET_TRUE_EXTENT ] );

        return_val = PMPI_Type_get_true_extent( datatype, true_lb, true_extent );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_TYPE_GET_TRUE_EXTENT ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_get_true_extent( datatype, true_lb, true_extent );
    }

    return return_val;
}
#endif

#if HAVE( DECL_MPI_TYPE_HINDEXED ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_TYPE )
/**
 * Measurement wrapper for MPI_Type_hindexed
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Type_hindexed( int           count,
                   int*          array_of_blocklengths,
                   MPI_Aint*     array_of_displacements,
                   MPI_Datatype  oldtype,
                   MPI_Datatype* newtype )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_TYPE ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_TYPE_HINDEXED ] );

        return_val = PMPI_Type_hindexed( count, array_of_blocklengths, array_of_displacements, oldtype, newtype );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_TYPE_HINDEXED ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_hindexed( count, array_of_blocklengths, array_of_displacements, oldtype, newtype );
    }

    return return_val;
}
#endif

#if HAVE( DECL_MPI_TYPE_HVECTOR ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_TYPE )
/**
 * Measurement wrapper for MPI_Type_hvector
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Type_hvector( int           count,
                  int           blocklength,
                  MPI_Aint      stride,
                  MPI_Datatype  oldtype,
                  MPI_Datatype* newtype )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_TYPE ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_TYPE_HVECTOR ] );

        return_val = PMPI_Type_hvector( count, blocklength, stride, oldtype, newtype );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_TYPE_HVECTOR ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_hvector( count, blocklength, stride, oldtype, newtype );
    }

    return return_val;
}
#endif

#if HAVE( DECL_MPI_TYPE_INDEXED ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_TYPE )
/**
 * Measurement wrapper for MPI_Type_indexed
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Type_indexed( int           count,
                  int*          array_of_blocklengths,
                  int*          array_of_displacements,
                  MPI_Datatype  oldtype,
                  MPI_Datatype* newtype )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_TYPE ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_TYPE_INDEXED ] );

        return_val = PMPI_Type_indexed( count, array_of_blocklengths, array_of_displacements, oldtype, newtype );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_TYPE_INDEXED ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_indexed( count, array_of_blocklengths, array_of_displacements, oldtype, newtype );
    }

    return return_val;
}
#endif

#if HAVE( DECL_MPI_TYPE_LB ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_TYPE )
/**
 * Measurement wrapper for MPI_Type_lb
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Type_lb( MPI_Datatype datatype,
             MPI_Aint*    displacement )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_TYPE ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_TYPE_LB ] );

        return_val = PMPI_Type_lb( datatype, displacement );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_TYPE_LB ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_lb( datatype, displacement );
    }

    return return_val;
}
#endif

#if HAVE( DECL_MPI_TYPE_MATCH_SIZE ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_TYPE )
/**
 * Measurement wrapper for MPI_Type_match_size
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Type_match_size( int           typeclass,
                     int           size,
                     MPI_Datatype* type )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_TYPE ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_TYPE_MATCH_SIZE ] );

        return_val = PMPI_Type_match_size( typeclass, size, type );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_TYPE_MATCH_SIZE ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_match_size( typeclass, size, type );
    }

    return return_val;
}
#endif

#if HAVE( DECL_MPI_TYPE_SIZE ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_TYPE )
/**
 * Measurement wrapper for MPI_Type_size
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Type_size( MPI_Datatype datatype,
               int*         size )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_TYPE ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_TYPE_SIZE ] );

        return_val = PMPI_Type_size( datatype, size );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_TYPE_SIZE ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_size( datatype, size );
    }

    return return_val;
}
#endif

#if HAVE( DECL_MPI_TYPE_STRUCT ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_TYPE )
/**
 * Measurement wrapper for MPI_Type_struct
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Type_struct( int           count,
                 int*          array_of_blocklengths,
                 MPI_Aint*     array_of_displacements,
                 MPI_Datatype* array_of_types,
                 MPI_Datatype* newtype )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_TYPE ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_TYPE_STRUCT ] );

        return_val = PMPI_Type_struct( count, array_of_blocklengths, array_of_displacements, array_of_types, newtype );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_TYPE_STRUCT ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_struct( count, array_of_blocklengths, array_of_displacements, array_of_types, newtype );
    }

    return return_val;
}
#endif

#if HAVE( DECL_MPI_TYPE_UB ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_TYPE )
/**
 * Measurement wrapper for MPI_Type_ub
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Type_ub( MPI_Datatype datatype,
             MPI_Aint*    displacement )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_TYPE ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_TYPE_UB ] );

        return_val = PMPI_Type_ub( datatype, displacement );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_TYPE_UB ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_ub( datatype, displacement );
    }

    return return_val;
}
#endif

#if HAVE( DECL_MPI_TYPE_VECTOR ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_TYPE )
/**
 * Measurement wrapper for MPI_Type_vector
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Type_vector( int           count,
                 int           blocklength,
                 int           stride,
                 MPI_Datatype  oldtype,
                 MPI_Datatype* newtype )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_TYPE ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_TYPE_VECTOR ] );

        return_val = PMPI_Type_vector( count, blocklength, stride, oldtype, newtype );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_TYPE_VECTOR ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_vector( count, blocklength, stride, oldtype, newtype );
    }

    return return_val;
}
#endif

#if HAVE( DECL_MPI_UNPACK ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_TYPE )
/**
 * Measurement wrapper for MPI_Unpack
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-1
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Unpack( void*        inbuf,
            int          insize,
            int*         position,
            void*        outbuf,
            int          outcount,
            MPI_Datatype datatype,
            MPI_Comm     comm )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_TYPE ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_UNPACK ] );

        return_val = PMPI_Unpack( inbuf, insize, position, outbuf, outcount, datatype, comm );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_UNPACK ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Unpack( inbuf, insize, position, outbuf, outcount, datatype, comm );
    }

    return return_val;
}
#endif

#if HAVE( DECL_MPI_UNPACK_EXTERNAL ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_TYPE )
/**
 * Measurement wrapper for MPI_Unpack_external
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup type
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Unpack_external( char*        datarep,
                     void*        inbuf,
                     MPI_Aint     insize,
                     MPI_Aint*    position,
                     void*        outbuf,
                     int          outcount,
                     MPI_Datatype datatype )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_TYPE ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_UNPACK_EXTERNAL ] );

        return_val = PMPI_Unpack_external( datarep, inbuf, insize, position, outbuf, outcount, datatype );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_UNPACK_EXTERNAL ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Unpack_external( datarep, inbuf, insize, position, outbuf, outcount, datatype );
    }

    return return_val;
}
#endif


/**
 * @}
 * @name C wrappers for external interface functions
 * @{
 */

#if HAVE( DECL_MPI_TYPE_CREATE_KEYVAL ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_TYPE ) && !defined( SILC_MPI_NO_EXT )
/**
 * Measurement wrapper for MPI_Type_create_keyval
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup type_ext
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Type_create_keyval( MPI_Type_copy_attr_function*   type_copy_attr_fn,
                        MPI_Type_delete_attr_function* type_delete_attr_fn,
                        int*                           type_keyval,
                        void*                          extra_state )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_TYPE_EXT ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_TYPE_CREATE_KEYVAL ] );

        return_val = PMPI_Type_create_keyval( type_copy_attr_fn, type_delete_attr_fn, type_keyval, extra_state );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_TYPE_CREATE_KEYVAL ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_create_keyval( type_copy_attr_fn, type_delete_attr_fn, type_keyval, extra_state );
    }

    return return_val;
}
#endif

#if HAVE( DECL_MPI_TYPE_DELETE_ATTR ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_TYPE ) && !defined( SILC_MPI_NO_EXT )
/**
 * Measurement wrapper for MPI_Type_delete_attr
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup type_ext
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Type_delete_attr( MPI_Datatype type,
                      int          type_keyval )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_TYPE_EXT ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_TYPE_DELETE_ATTR ] );

        return_val = PMPI_Type_delete_attr( type, type_keyval );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_TYPE_DELETE_ATTR ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_delete_attr( type, type_keyval );
    }

    return return_val;
}
#endif

#if HAVE( DECL_MPI_TYPE_FREE_KEYVAL ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_TYPE ) && !defined( SILC_MPI_NO_EXT )
/**
 * Measurement wrapper for MPI_Type_free_keyval
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup type_ext
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Type_free_keyval( int* type_keyval )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_TYPE_EXT ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_TYPE_FREE_KEYVAL ] );

        return_val = PMPI_Type_free_keyval( type_keyval );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_TYPE_FREE_KEYVAL ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_free_keyval( type_keyval );
    }

    return return_val;
}
#endif

#if HAVE( DECL_MPI_TYPE_GET_ATTR ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_TYPE ) && !defined( SILC_MPI_NO_EXT )
/**
 * Measurement wrapper for MPI_Type_get_attr
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup type_ext
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Type_get_attr( MPI_Datatype type,
                   int          type_keyval,
                   void*        attribute_val,
                   int*         flag )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_TYPE_EXT ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_TYPE_GET_ATTR ] );

        return_val = PMPI_Type_get_attr( type, type_keyval, attribute_val, flag );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_TYPE_GET_ATTR ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_get_attr( type, type_keyval, attribute_val, flag );
    }

    return return_val;
}
#endif

#if HAVE( DECL_MPI_TYPE_GET_NAME ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_TYPE ) && !defined( SILC_MPI_NO_EXT )
/**
 * Measurement wrapper for MPI_Type_get_name
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup type_ext
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Type_get_name( MPI_Datatype type,
                   char*        type_name,
                   int*         resultlen )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_TYPE_EXT ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_TYPE_GET_NAME ] );

        return_val = PMPI_Type_get_name( type, type_name, resultlen );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_TYPE_GET_NAME ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_get_name( type, type_name, resultlen );
    }

    return return_val;
}
#endif

#if HAVE( DECL_MPI_TYPE_SET_ATTR ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_TYPE ) && !defined( SILC_MPI_NO_EXT )
/**
 * Measurement wrapper for MPI_Type_set_attr
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup type_ext
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Type_set_attr( MPI_Datatype type,
                   int          type_keyval,
                   void*        attribute_val )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_TYPE_EXT ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_TYPE_SET_ATTR ] );

        return_val = PMPI_Type_set_attr( type, type_keyval, attribute_val );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_TYPE_SET_ATTR ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_set_attr( type, type_keyval, attribute_val );
    }

    return return_val;
}
#endif

#if HAVE( DECL_MPI_TYPE_SET_NAME ) && !defined( SILC_MPI_NO_EXTRA ) && !defined( SILC_MPI_NO_TYPE ) && !defined( SILC_MPI_NO_EXT )
/**
 * Measurement wrapper for MPI_Type_set_name
 * @note Auto-generated by wrapgen from template: SILC_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup type_ext
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Type_set_name( MPI_Datatype type,
                   char*        type_name )
{
    int return_val;

    if ( SILC_MPI_IS_EVENT_GEN_ON_FOR( SILC_MPI_ENABLED_TYPE_EXT ) )
    {
        SILC_MPI_EVENT_GEN_OFF();
        SILC_EnterRegion( silc_mpi_regid[ SILC__MPI_TYPE_SET_NAME ] );

        return_val = PMPI_Type_set_name( type, type_name );

        SILC_ExitRegion( silc_mpi_regid[ SILC__MPI_TYPE_SET_NAME ] );
        SILC_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Type_set_name( type, type_name );
    }

    return return_val;
}
#endif


/**
 * @}
 * @name C wrappers for handle conversion functions
 * @{
 */


/**
 * @}
 */
