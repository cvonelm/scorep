/*
 * This file is part of the Score-P software (http://www.score-p.org)
 *
 * Copyright (c) 2009-2013,
 * RWTH Aachen University, Germany
 *
 * Copyright (c) 2009-2013,
 * Gesellschaft fuer numerische Simulation mbH Braunschweig, Germany
 *
 * Copyright (c) 2009-2013, 2015, 2019-2020,
 * Technische Universitaet Dresden, Germany
 *
 * Copyright (c) 2009-2013,
 * University of Oregon, Eugene, USA
 *
 * Copyright (c) 2009-2013, 2022,
 * Forschungszentrum Juelich GmbH, Germany
 *
 * Copyright (c) 2009-2013,
 * German Research School for Simulation Sciences GmbH, Juelich/Aachen, Germany
 *
 * Copyright (c) 2009-2013,
 * Technische Universitaet Muenchen, Germany
 *
 * This software may be modified and distributed under the terms of
 * a BSD-style license.  See the COPYING file in the package base
 * directory for details.
 */


/**
 * @file
 *
 * @brief Support for XL IBM-Compiler
 * Will be triggered by the function trace option by the xl
 * compiler.
 */

#include <config.h>

#if !( ( defined( __IBMC__ ) && __IBMC__ > 1100 ) || defined( __ibmxl__ ) )
#error Need XL compiler version 11 or newer
/* 11.1 was released 2011-11 */
#endif

#include <stdlib.h>
#include <string.h>

#include <UTILS_Error.h>
#define SCOREP_DEBUG_MODULE_NAME COMPILER
#include <UTILS_Debug.h>

#include <UTILS_IO.h>
#include <UTILS_CStr.h>
#include <UTILS_Mutex.h>

#include <SCOREP_RuntimeManagement.h>
#include <SCOREP_InMeasurement.h>
#include <SCOREP_Events.h>
#include <SCOREP_Filtering.h>

#include "scorep_compiler_data.h"
#include "scorep_compiler_demangle.h"

static Utils_Mutex func_trace_register_region_mutex = UTILS_MUTEX_INIT;

/**
 * Looks up the region name in the hash table, registers the region
 * if it is not already registered and returns the region handle.
 * If the region is filtered it returns SCOREP_INVALID_REGION.
 * @ param regionName function name
 * @ param fileName   file name
 * @ param lineNo     line number
 */
static inline SCOREP_RegionHandle
func_trace_register_region( const char* regionName,
                            const char* fileName,
                            int         lineNo )
{
    UTILS_DEBUG_ENTRY( "%s in %s:%d", regionName, fileName, lineNo );

    size_t file_name_len = strlen( fileName );
    char   file_name[ file_name_len + 1 ];
    memcpy( file_name, fileName, file_name_len );
    file_name[ file_name_len ] = '\0';
    UTILS_IO_SimplifyPath( file_name );
    if ( SCOREP_Filtering_MatchFile( file_name ) )
    {
        return SCOREP_FILTERED_REGION;
    }

    SCOREP_RegionHandle region_handle = SCOREP_FILTERED_REGION;

    const char* region_name_demangled;
    scorep_compiler_demangle( regionName, region_name_demangled );
    /* Check for filters:
         1. In case OpenMP is used, the XL compiler creates some
            functions like <func_name>:<func_name>$OL$OL.1 on BG/P or
            <func_name>@OL@1 on AIX which cause the measurement system
            to crash. Thus, filter functions which names contain a '$'
            or '@' symbol.
            or the symbol starts with '__xl_' and has '_OL_' in it
         2. POMP and POMP2 functions.
     */
    if ( strchr( region_name_demangled, '$' ) ||
         strchr( region_name_demangled, '@' ) ||
         strncmp( region_name_demangled, "POMP", 4 ) == 0 ||
         strncmp( region_name_demangled, "Pomp", 4 ) == 0 ||
         strncmp( region_name_demangled, "pomp", 4 ) == 0 ||
         strstr( region_name_demangled, "Kokkos::Tools" ) ||
         strstr( region_name_demangled, "Kokkos::Profiling" ) ||
         /* Best effort at mangled name in case we don't have a demangler
            and demangled == mangled */
         strstr( region_name_demangled, "6Kokkos5Tools" ) ||
         strstr( region_name_demangled, "6Kokkos9Profiling" ) ||
         ( strncmp( region_name_demangled, "__xl_", 5 ) == 0 && strstr( region_name_demangled, "_OL_" ) ) ||
         SCOREP_Filtering_MatchFunction( region_name_demangled, regionName ) )
    {
        SCOREP_SourceFileHandle file_handle = SCOREP_Definitions_NewSourceFile( file_name );
        region_handle = SCOREP_Definitions_NewRegion( region_name_demangled,
                                                      regionName,
                                                      file_handle,
                                                      lineNo,
                                                      SCOREP_INVALID_LINE_NO,
                                                      SCOREP_PARADIGM_COMPILER,
                                                      SCOREP_REGION_FUNCTION );
    }

    return region_handle;
}

/**
 * @ brief This function is called at the entry of each function.
 * The call is generated by the IBM xl compilers
 *
 * @ param region_name function name
 * @ param file_name   file name
 * @ param line_no     line number
 */
void
__func_trace_enter( const char*          regionName,
                    const char*          fileName,
                    int                  lineNo,
                    SCOREP_RegionHandle* regionHandle )
{
    SCOREP_IN_MEASUREMENT_INCREMENT();
    if ( SCOREP_IS_MEASUREMENT_PHASE( PRE ) )
    {
        SCOREP_InitMeasurement();
    }
    if ( !SCOREP_IS_MEASUREMENT_PHASE( WITHIN ) || SCOREP_IsUnwindingEnabled() )
    {
        UTILS_Atomic_StoreN_void_ptr( &regionHandle,
                                      SCOREP_INVALID_REGION,
                                      UTILS_ATOMIC_SEQUENTIAL_CONSISTENT );
        SCOREP_IN_MEASUREMENT_DECREMENT();
        return;
    }

    SCOREP_RegionHandle* handle =
        UTILS_Atomic_LoadN_void_ptr( &regionHandle,
                                     UTILS_ATOMIC_SEQUENTIAL_CONSISTENT );
    if ( *handle == 0 )
    {
        UTILS_MutexLock( &func_trace_register_region_mutex );
        handle = UTILS_Atomic_LoadN_void_ptr( &regionHandle,
                                              UTILS_ATOMIC_SEQUENTIAL_CONSISTENT );
        if ( *handle == 0 )
        {
            *handle = func_trace_register_region( regionName, fileName, lineNo );
            UTILS_Atomic_StoreN_void_ptr( &regionHandle,
                                          handle,
                                          UTILS_ATOMIC_SEQUENTIAL_CONSISTENT );
        }
        UTILS_MutexUnlock( &func_trace_register_region_mutex );
    }
    if ( *handle != SCOREP_FILTERED_REGION )
    {
        SCOREP_EnterRegion( *handle );
    }

    SCOREP_IN_MEASUREMENT_DECREMENT();
}

/**
 * @ brief This function is called at the exit of each function.
 * The call is generated by the IBM xl compilers
 *
 * @ param region_name function name
 * @ param file_name   file name
 * @ param line_no     line number
 */
void
__func_trace_exit( const char*          region_name,
                   const char*          file_name,
                   int                  line_no,
                   SCOREP_RegionHandle* handle )
{
    SCOREP_IN_MEASUREMENT_INCREMENT();
    if ( !SCOREP_IS_MEASUREMENT_PHASE( WITHIN ) || SCOREP_IsUnwindingEnabled() )
    {
        SCOREP_IN_MEASUREMENT_DECREMENT();
        return;
    }

    UTILS_DEBUG_ENTRY();

    if ( *handle != SCOREP_FILTERED_REGION )
    {
        SCOREP_ExitRegion( *handle );
    }

    SCOREP_IN_MEASUREMENT_DECREMENT();
}
